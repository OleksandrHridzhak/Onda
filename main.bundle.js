/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./api/ipcCalendarHandlers.js":
/*!************************************!*\
  !*** ./api/ipcCalendarHandlers.js ***!
  \************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{const path = __webpack_require__(/*! path */ \"path\");\nconst { saveData, getData } = __webpack_require__(/*! ../utils/dataUtils */ \"./utils/dataUtils.js\");\nconst DATA_FILE = path.join(__dirname, '../userData/calendar.json');\n\nmodule.exports = {\n  init(ipcMain) {\n    // Get all calendar events\n    ipcMain.handle('calendar-get-events', async () => {\n      try {\n        const data = await getData(DATA_FILE);\n        // Ensure backward compatibility\n        const normalizedData = data.map((event) => ({\n          ...event,\n          isRepeating: event.isRepeating ?? false,\n          repeatDays: event.repeatDays ?? [],\n          repeatFrequency: event.repeatFrequency ?? 'weekly',\n        }));\n        return { status: 'success', data: normalizedData };\n      } catch (error) {\n        return { status: 'error', error: error.message };\n      }\n    });\n\n    // Save or update a single calendar event\n    ipcMain.handle('calendar-save-event', async (event, eventData) => {\n      try {\n        let events = await getData(DATA_FILE);\n\n        // Validate repeat settings\n        const normalizedEvent = {\n          ...eventData,\n          isRepeating: eventData.isRepeating ?? false,\n          repeatDays: eventData.isRepeating\n            ? Array.isArray(eventData.repeatDays)\n              ? eventData.repeatDays\n              : []\n            : [],\n          repeatFrequency: eventData.isRepeating\n            ? eventData.repeatFrequency || 'weekly'\n            : 'weekly',\n        };\n\n        const index = events.findIndex((e) => e.id === eventData.id);\n        if (index !== -1) {\n          // Update existing event\n          events[index] = normalizedEvent;\n        } else {\n          // Add new event\n          events.push({\n            ...normalizedEvent,\n            id: eventData.id || Date.now().toString(),\n          });\n        }\n\n        await saveData(DATA_FILE, events);\n        return { status: 'success', data: normalizedEvent };\n      } catch (error) {\n        return { status: 'error', error: error.message };\n      }\n    });\n\n    // Delete a single calendar event\n    ipcMain.handle('calendar-delete-event', async (event, eventId) => {\n      try {\n        let events = await getData(DATA_FILE);\n\n        const initialLength = events.length;\n        events = events.filter((e) => e.id !== eventId);\n\n        if (events.length === initialLength) {\n          return { status: 'error', message: 'Event not found' };\n        }\n\n        await saveData(DATA_FILE, events);\n        return { status: 'success', message: 'Event deleted', eventId };\n      } catch (error) {\n        return { status: 'error', error: error.message };\n      }\n    });\n\n    // Get current time\n    ipcMain.handle('calendar-get-time', async () => {\n      const now = new Date();\n      return { status: 'success', time: now.toISOString() };\n    });\n  },\n};\n\n\n//# sourceURL=webpack://onda-app-dev/./api/ipcCalendarHandlers.js?\n}");

/***/ }),

/***/ "./api/ipcSettingsHandlers.js":
/*!************************************!*\
  !*** ./api/ipcSettingsHandlers.js ***!
  \************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{const { app, Notification, dialog } = __webpack_require__(/*! electron */ \"electron\");\nconst path = __webpack_require__(/*! path */ \"path\");\nconst DATA_FILE = path.join(__dirname, '../userData/data.json');\nconst CALENDAR_FILE = path.join(__dirname, '../userData/calendar.json');\nconst SETTINGS_FILE = path.join(__dirname, '../userData/settings.json');\nconst { getSettingsTemplates } = __webpack_require__(/*! ../constants/fileTemplates.js */ \"./constants/fileTemplates.js\");\nconst { saveData, getData } = __webpack_require__(/*! ../utils/dataUtils.js */ \"./utils/dataUtils.js\");\nconst { updateThemeBasedOnTime } = __webpack_require__(/*! ../utils/utils.js */ \"./utils/utils.js\");\n\nconst handleError = (err, message) => ({\n  status: message,\n  error: err.message,\n});\n\nmodule.exports = {\n  init(ipcMain) {\n    ipcMain.handle('switch-theme', async (event, darkMode) => {\n      try {\n        const settings = await getData(SETTINGS_FILE, () =>\n          getSettingsTemplates()\n        );\n        settings.theme.darkMode = darkMode;\n        await saveData(SETTINGS_FILE, settings, () => getSettingsTemplates());\n        return { status: 'Theme switched', darkMode };\n      } catch (err) {\n        return handleError(err, 'Error parsing settings');\n      }\n    });\n\n    ipcMain.handle('get-theme', async () => {\n      try {\n        const settings = await getData(SETTINGS_FILE, () =>\n          getSettingsTemplates()\n        );\n        return { status: 'Theme fetched', darkMode: settings.theme.darkMode };\n      } catch (err) {\n        return handleError(err, 'Error parsing settings');\n      }\n    });\n\n    ipcMain.handle('get-cell-settings', async () => {\n      try {\n        const settings = await getData(SETTINGS_FILE, () =>\n          getSettingsTemplates()\n        );\n        return {\n          status: 'Cell settings fetched',\n          cellSettings: settings.theme.cellSettings || {},\n        };\n      } catch (err) {\n        return handleError(err, 'Error parsing settings');\n      }\n    });\n    ipcMain.handle('get-settings', async () => {\n      try {\n        const settings = await getData(SETTINGS_FILE, () =>\n          getSettingsTemplates()\n        );\n        return { status: 'Settings fetched', data: settings };\n      } catch (err) {\n        return handleError(err, 'Error parsing settings');\n      }\n    });\n\n    ipcMain.handle('update-settings', async (event, settings) => {\n      try {\n        await saveData(SETTINGS_FILE, settings, () => getSettingsTemplates());\n        return { status: 'Settings updated' };\n      } catch (err) {\n        return handleError(err, 'Error updating settings');\n      }\n    });\n\n    ipcMain.handle('update-theme', async (event, themeSettings) => {\n      try {\n        const settings = await getData(SETTINGS_FILE, () =>\n          getSettingsTemplates()\n        );\n        settings.theme = { ...settings.theme, ...themeSettings };\n        await saveData(SETTINGS_FILE, settings, () => getSettingsTemplates());\n        updateThemeBasedOnTime();\n        return { status: 'Theme updated' };\n      } catch (err) {\n        return handleError(err, 'Error updating theme');\n      }\n    });\n\n    ipcMain.handle('update-table-settings', async (event, tableSettings) => {\n      try {\n        const settings = await getData(SETTINGS_FILE, () =>\n          getSettingsTemplates()\n        );\n        settings.table = { ...settings.table, ...tableSettings };\n        await saveData(SETTINGS_FILE, settings, () => getSettingsTemplates());\n        return { status: 'Table settings updated' };\n      } catch (err) {\n        return handleError(err, 'Error updating table settings');\n      }\n    });\n\n    ipcMain.handle('update-ui-settings', async (event, uiSettings) => {\n      try {\n        const settings = await getData(SETTINGS_FILE, () =>\n          getSettingsTemplates()\n        );\n        settings.ui = { ...settings.ui, ...uiSettings };\n        await saveData(SETTINGS_FILE, settings, () => getSettingsTemplates());\n        return { status: 'UI settings updated' };\n      } catch (err) {\n        return handleError(err, 'Error updating UI settings');\n      }\n    });\n\n    ipcMain.handle('update-column-order', async (event, columnOrder) => {\n      try {\n        const settings = await getData(SETTINGS_FILE, () =>\n          getSettingsTemplates()\n        );\n        settings.table.columnOrder = columnOrder;\n        await saveData(SETTINGS_FILE, settings, () => getSettingsTemplates());\n        return { status: 'Column order updated' };\n      } catch (err) {\n        return handleError(err, 'Error updating column order');\n      }\n    });\n\n    ipcMain.handle('show-notification', (event, { title, body }) => {\n      new Notification({ title, body }).show();\n    });\n\n    ipcMain.handle('export-data', async () => {\n      try {\n        const [data, calendarData, settings] = await Promise.all([\n          getData(DATA_FILE),\n          getData(CALENDAR_FILE),\n          getData(SETTINGS_FILE, () => getSettingsTemplates()),\n        ]);\n\n        const exportData = {\n          data,\n          calendar: calendarData,\n          settings,\n        };\n\n        const { filePath } = await dialog.showSaveDialog({\n          title: 'Data export',\n          defaultPath: path.join(app.getPath('documents'), 'onda-data.json'),\n          filters: [{ name: 'JSON Files', extensions: ['json'] }],\n        });\n\n        if (!filePath) {\n          return { status: 'Export cancelled' };\n        }\n\n        await saveData(filePath, exportData);\n        return { status: 'Data exported', filePath };\n      } catch (error) {\n        console.error('Error exporting data:', error);\n        return handleError(error, 'Export failed');\n      }\n    });\n\n    ipcMain.handle('import-data', async () => {\n      try {\n        const { filePaths } = await dialog.showOpenDialog({\n          title: 'Data import',\n          defaultPath: app.getPath('documents'),\n          filters: [{ name: 'JSON Files', extensions: ['json'] }],\n          properties: ['openFile'],\n        });\n\n        if (!filePaths || filePaths.length === 0) {\n          return { status: 'Import cancelled' };\n        }\n\n        const importData = await getData(filePaths[0]);\n        if (importData.data) {\n          await saveData(DATA_FILE, importData.data);\n        }\n        if (importData.calendar) {\n          await saveData(CALENDAR_FILE, importData.calendar);\n        }\n        if (importData.settings) {\n          await saveData(SETTINGS_FILE, importData.settings, () =>\n            getSettingsTemplates()\n          );\n        }\n\n        return { status: 'Data imported' };\n      } catch (error) {\n        console.error('Error importing data:', error);\n        return handleError(error, 'Import failed');\n      }\n    });\n  },\n};\n\n\n//# sourceURL=webpack://onda-app-dev/./api/ipcSettingsHandlers.js?\n}");

/***/ }),

/***/ "./api/ipcTableHandlers.js":
/*!*********************************!*\
  !*** ./api/ipcTableHandlers.js ***!
  \*********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{const path = __webpack_require__(/*! path */ \"path\");\nconst { getData, saveData } = __webpack_require__(/*! ../utils/dataUtils.js */ \"./utils/dataUtils.js\");\nconst DATA_FILE = path.join(__dirname, '../userData/data.json');\n\nconst { getColumnTemplates } = __webpack_require__(/*! ../constants/fileTemplates.js */ \"./constants/fileTemplates.js\");\n\nmodule.exports = {\n  init(ipcMain) {\n    // Save data to data.json\n    ipcMain.handle('save-data', async (event, data) => {\n      await saveData(DATA_FILE, data);\n      return { status: 'Data saved!' };\n    });\n    // Get current time\n    ipcMain.handle('get-time', () => {\n      const now = new Date();\n      return { time: now.toISOString() };\n    });\n\n    // Get all data from data.json\n    ipcMain.handle('get-table-data', async () => {\n      try {\n        const data = await getData(DATA_FILE);\n        return { status: 'Data fetched', data };\n      } catch (err) {\n        return { status: 'Error parsing data', error: err.message };\n      }\n    });\n\n    // Update a column in data.json\n    ipcMain.handle('column-change', async (event, updatedColumn) => {\n      const data = await getData(DATA_FILE);\n\n      const index = data.findIndex(\n        (item) => item.ColumnId === updatedColumn.ColumnId\n      );\n\n      if (index === -1) {\n        return { status: 'Column not found' };\n      }\n\n      data[index] = updatedColumn;\n      await saveData(DATA_FILE, data);\n      return { status: 'Column updated', data: updatedColumn };\n    });\n\n    // Create a new component in data.json\n    ipcMain.handle('create-component', async (event, type) => {\n      const templates = getColumnTemplates();\n      if (!templates[type]) {\n        return {\n          status: 'Invalid type',\n          error: `No template for type \"${type}\"`,\n        };\n      }\n\n      const newComponent = templates[type];\n      let data;\n      try {\n        data = await getData(DATA_FILE);\n      } catch (err) {\n        return { status: 'Error parsing file', error: err.message };\n      }\n\n      data.push(newComponent);\n      await saveData(DATA_FILE, data);\n      return { status: 'Success', data: newComponent };\n    });\n\n    // Delete a component from data.json\n    ipcMain.handle('delete-component', async (event, columnId) => {\n      let data;\n      try {\n        data = await getData(DATA_FILE);\n      } catch (err) {\n        return { status: 'Error parsing data', error: err.message };\n      }\n\n      const initialLength = data.length;\n      data = data.filter((item) => item.ColumnId !== columnId);\n\n      if (data.length === initialLength) {\n        return { status: 'Component not found', columnId };\n      }\n      await saveData(DATA_FILE, data);\n      return { status: 'Component deleted', columnId };\n    });\n    ipcMain.handle('collect-metrics', () => {\n      const mem = process.memoryUsage();\n      const cpu = process.cpuUsage();\n      return {\n        rss: mem.rss,\n        heapUsed: mem.heapUsed,\n        heapTotal: mem.heapTotal,\n        cpuUser: cpu.user,\n        cpuSystem: cpu.system\n      };\n      });\n  },\n};\n\n\n//# sourceURL=webpack://onda-app-dev/./api/ipcTableHandlers.js?\n}");

/***/ }),

/***/ "./api/ipcWindowHandlers.js":
/*!**********************************!*\
  !*** ./api/ipcWindowHandlers.js ***!
  \**********************************/
/***/ ((module) => {

eval("{module.exports = {\n  init(ipcMain, mainWindow) {\n    // Window close handler\n    ipcMain.handle('window-close', () => {\n      mainWindow.hide();\n    });\n\n    //WIndow minimize handler\n    ipcMain.handle('window-minimize', () => {\n      mainWindow.minimize();\n    });\n\n    // Window maximize handler OR restore WINDOW\n    ipcMain.handle('window-maximize', () => {\n      if (mainWindow.isMaximized()) {\n        mainWindow.restore();\n      } else {\n        mainWindow.maximize();\n      }\n    });\n\n    // Tab navigation handlers\n    ipcMain.on('next-tab', () => {\n      mainWindow.webContents.send('next-tab');\n    });\n  },\n};\n\n\n//# sourceURL=webpack://onda-app-dev/./api/ipcWindowHandlers.js?\n}");

/***/ }),

/***/ "./constants/fileTemplates.js":
/*!************************************!*\
  !*** ./constants/fileTemplates.js ***!
  \************************************/
/***/ ((module) => {

eval("{const getColumnTemplates = () => ({\n  todo: {\n    ColumnId: Date.now().toString(),\n    Type: 'todo',\n    Name: 'Todo List',\n    Description: 'Todo list created on backend',\n    EmojiIcon: 'ListTodo',\n    NameVisible: true,\n    Chosen: {\n      global: [],\n    },\n    Options: ['Option 1', 'Option 2'],\n    TagColors: {\n      'Option 1': 'blue',\n      'Option 2': 'green',\n    },\n    Width: 150,\n  },\n  checkbox: {\n    ColumnId: Date.now().toString(),\n    Type: 'checkbox',\n    Name: 'New Checkbox',\n    Description: 'Checkbox created on backend',\n    EmojiIcon: 'Star',\n    NameVisible: false,\n    Chosen: {\n      Monday: false,\n      Tuesday: false,\n      Wednesday: false,\n      Thursday: false,\n      Friday: false,\n      Saturday: false,\n      Sunday: false,\n    },\n    Width: 50,\n    CheckboxColor: 'green',\n  },\n  numberbox: {\n    ColumnId: Date.now().toString(),\n    Type: 'numberbox',\n    Name: 'New Numberbox',\n    Description: 'Numberbox created on backend',\n    EmojiIcon: 'Star',\n    NameVisible: false,\n    Chosen: {\n      Monday: '',\n      Tuesday: '',\n      Wednesday: '',\n      Thursday: '',\n      Friday: '',\n      Saturday: '',\n      Sunday: '',\n    },\n    Width: 60,\n  },\n  text: {\n    ColumnId: Date.now().toString(),\n    Type: 'text',\n    Name: 'New Text',\n    Description: 'Text created on backend',\n    EmojiIcon: 'Star',\n    NameVisible: true,\n    Chosen: {\n      Monday: '',\n      Tuesday: '',\n      Wednesday: '',\n      Thursday: '',\n      Friday: '',\n      Saturday: '',\n      Sunday: '',\n    },\n    Width: 130,\n  },\n  multiSelect: {\n    ColumnId: Date.now().toString(),\n    Type: 'multi-select',\n    Name: 'New Multi-Select',\n    Description: 'Multi-select created on backend',\n    EmojiIcon: 'Star',\n    NameVisible: true,\n    Options: ['Option 1', 'Option 2'],\n    TagColors: {\n      'Option 1': 'blue',\n      'Option 2': 'green',\n    },\n    Chosen: {\n      Monday: '',\n      Tuesday: '',\n      Wednesday: '',\n      Thursday: '',\n      Friday: '',\n      Saturday: '',\n      Sunday: '',\n    },\n    Width: 90,\n  },\n  multicheckbox: {\n    ColumnId: Date.now().toString(),\n    Type: 'multicheckbox',\n    Name: 'New Multi Checkbox',\n    Description: 'Multi-checkbox created on backend',\n    EmojiIcon: 'Circle',\n    NameVisible: false,\n    Options: ['Task 1', 'Task 2'],\n    TagColors: {\n      'Task 1': 'blue',\n      'Task 2': 'green',\n    },\n    Chosen: {\n      Monday: '',\n      Tuesday: '',\n      Wednesday: '',\n      Thursday: '',\n      Friday: '',\n      Saturday: '',\n      Sunday: '',\n    },\n    Width: 50,\n  },\n  tasktable: {\n    ColumnId: Date.now().toString(),\n    Type: 'tasktable',\n    Name: 'New Task List',\n    Description: 'Task table created on backend',\n    EmojiIcon: 'ListTodo',\n    NameVisible: true,\n    Options: ['Task 1', 'Task 2'],\n    TagColors: {\n      'Task 1': 'blue',\n      'Task 2': 'green',\n    },\n    Chosen: {\n      global: [],\n    },\n    Width: 150,\n  },\n});\n\nconst getSettingsTemplates = () => ({\n  theme: {\n    darkMode: false,\n    accentColor: 'blue',\n    autoThemeSettings: {\n      enabled: false,\n      startTime: '08:00',\n      endTime: '20:00',\n    },\n  },\n  table: {\n    columnOrder: [],\n    showSummaryRow: false,\n    compactMode: false,\n    stickyHeader: true,\n  },\n  ui: {\n    animations: true,\n    tooltips: true,\n    confirmDelete: true,\n  },\n});\n\nmodule.exports = { getColumnTemplates, getSettingsTemplates };\n\n\n//# sourceURL=webpack://onda-app-dev/./constants/fileTemplates.js?\n}");

/***/ }),

/***/ "./main.js":
/*!*****************!*\
  !*** ./main.js ***!
  \*****************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval("{const { app, BrowserWindow, ipcMain } = __webpack_require__(/*! electron */ \"electron\");\r\nconst path = __webpack_require__(/*! path */ \"path\");\r\nconst ipcTableHandlers = __webpack_require__(/*! ./api/ipcTableHandlers.js */ \"./api/ipcTableHandlers.js\");\r\nconst ipcCalendarHandlers = __webpack_require__(/*! ./api/ipcCalendarHandlers.js */ \"./api/ipcCalendarHandlers.js\");\r\nconst ipcWindowHandlers = __webpack_require__(/*! ./api/ipcWindowHandlers.js */ \"./api/ipcWindowHandlers.js\");\r\nconst ipcSettingsHandlers = __webpack_require__(/*! ./api/ipcSettingsHandlers.js */ \"./api/ipcSettingsHandlers.js\");\r\n\r\n(__webpack_require__(/*! dotenv */ \"./node_modules/dotenv/lib/main.js\").config)();\r\n\r\nconst { initCronJobs } = __webpack_require__(/*! ./services/cronServices.js */ \"./services/cronServices.js\");\r\n//TODO create commits rules\r\n//TODO find on the internet how to improve solo dev system\r\n\r\nlet mainWindow;\r\n\r\nfunction createWindow() {\r\n  mainWindow = new BrowserWindow({\r\n    width: 1920,\r\n    height: 1080,\r\n    icon: path.join(__dirname, './assets/onda-logo.ico'),\r\n    frame: false,\r\n    webPreferences: {\r\n      \r\n      nodeIntegration: false,\r\n      contextIsolation: true,\r\n      preload: path.join(__dirname, 'preload.bundle.js'),\r\n      // Allow use of the <webview> tag in renderer\r\n      webviewTag: true,\r\n      webSecurity: false,\r\n      webviewTag: true,\r\n    },\r\n  });\r\n  \r\n\r\n  console.log('env:', \"development\");\r\n  if (true) {\r\n    mainWindow.loadURL('http://localhost:3000');\r\n  } else // removed by dead control flow\n{}\r\n}\r\n\r\n// Enable global shortcuts\r\nconst gotTheLock = app.requestSingleInstanceLock();\r\n\r\nif (!gotTheLock) {\r\n  app.quit();\r\n} else {\r\n  app.on('second-instance', () => {\r\n    if (mainWindow) {\r\n      if (mainWindow.isMinimized()) mainWindow.restore();\r\n      if (!mainWindow.isVisible()) mainWindow.show();\r\n      mainWindow.focus();\r\n    }\r\n  });\r\n\r\n  app.whenReady().then(() => {\r\n    // Remove X-Frame-Options and Content-Security-Policy headers to allow embedding sites in webview\r\n    const { session } = __webpack_require__(/*! electron */ \"electron\");\r\n    session.defaultSession.webRequest.onHeadersReceived((details, callback) => {\r\n      const responseHeaders = Object.fromEntries(\r\n        Object.entries(details.responseHeaders).filter(\r\n          (header) =>\r\n            !['x-frame-options', 'content-security-policy'].includes(\r\n              header[0].toLowerCase()\r\n            )\r\n        )\r\n      );\r\n      callback({ responseHeaders });\r\n    });\r\n\r\n    createWindow();\r\n    ipcTableHandlers.init(ipcMain);\r\n    ipcCalendarHandlers.init(ipcMain);\r\n    ipcSettingsHandlers.init(ipcMain);\r\n    ipcWindowHandlers.init(ipcMain, mainWindow);\r\n    initCronJobs();\r\n  });\r\n\r\n  app.on('activate', () => {\r\n    if (BrowserWindow.getAllWindows().length === 0) {\r\n      createWindow();\r\n    } else {\r\n      if (mainWindow.isMinimized()) mainWindow.restore();\r\n      if (!mainWindow.isVisible()) mainWindow.show();\r\n      mainWindow.focus();\r\n    }\r\n  });\r\n\r\n  app.on('window-all-closed', () => {\r\n    if (process.platform !== 'darwin') {\r\n      app.quit();\r\n    }\r\n  });\r\n}\r\n\r\n// const { app, BrowserWindow, ipcMain, globalShortcut, Tray, Menu } = require('electron');\r\n// const path = require('path');\r\n// const api = require(path.join(__dirname, './api/api.js'));\r\n// const calendarBackend = require('./api/calendar');\r\n\r\n// const { initCronJobs } = require('./services/cronServices');\r\n\r\n// let mainWindow;\r\n// let tray = null;\r\n\r\n// function createWindow() {\r\n//   mainWindow = new BrowserWindow({\r\n//     width: 1920,\r\n//     height: 1080,\r\n//     icon: path.join(__dirname, './assets/onda-logo.ico'),\r\n//     frame: false,\r\n//     webPreferences: {\r\n//       nodeIntegration: false,\r\n//       contextIsolation: true,\r\n//       preload: path.join(__dirname, 'preload.js'),\r\n//     },\r\n//   });\r\n\r\n//   mainWindow.loadURL('http://localhost:3000');\r\n//   mainWindow.maximize();\r\n// }\r\n\r\n// const gotTheLock = app.requestSingleInstanceLock();\r\n\r\n// if (!gotTheLock) {\r\n//   app.quit();\r\n// } else {\r\n//   app.on('second-instance', () => {\r\n//     if (mainWindow) {\r\n//       if (mainWindow.isMinimized()) mainWindow.restore();\r\n//       if (!mainWindow.isVisible()) mainWindow.show();\r\n//       mainWindow.focus();\r\n//     }\r\n//   });\r\n\r\n//   app.whenReady().then(() => {\r\n//     createWindow();\r\n//     api.init(ipcMain, mainWindow);\r\n//     calendarBackend.init(ipcMain, mainWindow);\r\n//     initCronJobs();\r\n\r\n//     tray = new Tray(path.join(__dirname, './assets/onda-logo.ico'));\r\n//     const trayMenu = Menu.buildFromTemplate([\r\n//       {\r\n//         label: 'Показати',\r\n//         click: () => {\r\n//           if (mainWindow) {\r\n//             mainWindow.show();\r\n//           }\r\n//         },\r\n//       },\r\n//       {\r\n//         label: 'Вийти',\r\n//         click: () => {\r\n//           app.quit();\r\n//         },\r\n//       },\r\n//     ]);\r\n//     tray.setToolTip('Onda App');\r\n//     tray.setContextMenu(trayMenu);\r\n\r\n//     tray.on('click', () => {\r\n//       if (mainWindow) {\r\n//         mainWindow.isVisible() ? mainWindow.hide() : mainWindow.show();\r\n//       }\r\n//     });\r\n//   });\r\n\r\n//   app.on('activate', () => {\r\n//     if (BrowserWindow.getAllWindows().length === 0) {\r\n//       createWindow();\r\n//     } else {\r\n//       if (mainWindow.isMinimized()) mainWindow.restore();\r\n//       if (!mainWindow.isVisible()) mainWindow.show();\r\n//       mainWindow.focus();\r\n//     }\r\n//   });\r\n\r\n//   app.on('window-all-closed', () => {\r\n//     if (process.platform !== 'darwin') {\r\n//       app.quit();\r\n//     }\r\n//   });\r\n// }\r\n\n\n//# sourceURL=webpack://onda-app-dev/./main.js?\n}");

/***/ }),

/***/ "./node_modules/dotenv/lib/main.js":
/*!*****************************************!*\
  !*** ./node_modules/dotenv/lib/main.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{const fs = __webpack_require__(/*! fs */ \"fs\")\nconst path = __webpack_require__(/*! path */ \"path\")\nconst os = __webpack_require__(/*! os */ \"os\")\nconst crypto = __webpack_require__(/*! crypto */ \"crypto\")\nconst packageJson = __webpack_require__(/*! ../package.json */ \"./node_modules/dotenv/package.json\")\n\nconst version = packageJson.version\n\n// Array of tips to display randomly\nconst TIPS = [\n  '🔐 encrypt with Dotenvx: https://dotenvx.com',\n  '🔐 prevent committing .env to code: https://dotenvx.com/precommit',\n  '🔐 prevent building .env in docker: https://dotenvx.com/prebuild',\n  '📡 add observability to secrets: https://dotenvx.com/ops',\n  '👥 sync secrets across teammates & machines: https://dotenvx.com/ops',\n  '🗂️ backup and recover secrets: https://dotenvx.com/ops',\n  '✅ audit secrets and track compliance: https://dotenvx.com/ops',\n  '🔄 add secrets lifecycle management: https://dotenvx.com/ops',\n  '🔑 add access controls to secrets: https://dotenvx.com/ops',\n  '🛠️  run anywhere with `dotenvx run -- yourcommand`',\n  '⚙️  specify custom .env file path with { path: \\'/custom/path/.env\\' }',\n  '⚙️  enable debug logging with { debug: true }',\n  '⚙️  override existing env vars with { override: true }',\n  '⚙️  suppress all logs with { quiet: true }',\n  '⚙️  write to custom object with { processEnv: myObject }',\n  '⚙️  load multiple .env files with { path: [\\'.env.local\\', \\'.env\\'] }'\n]\n\n// Get a random tip from the tips array\nfunction _getRandomTip () {\n  return TIPS[Math.floor(Math.random() * TIPS.length)]\n}\n\nfunction parseBoolean (value) {\n  if (typeof value === 'string') {\n    return !['false', '0', 'no', 'off', ''].includes(value.toLowerCase())\n  }\n  return Boolean(value)\n}\n\nfunction supportsAnsi () {\n  return process.stdout.isTTY // && process.env.TERM !== 'dumb'\n}\n\nfunction dim (text) {\n  return supportsAnsi() ? `\\x1b[2m${text}\\x1b[0m` : text\n}\n\nconst LINE = /(?:^|^)\\s*(?:export\\s+)?([\\w.-]+)(?:\\s*=\\s*?|:\\s+?)(\\s*'(?:\\\\'|[^'])*'|\\s*\"(?:\\\\\"|[^\"])*\"|\\s*`(?:\\\\`|[^`])*`|[^#\\r\\n]+)?\\s*(?:#.*)?(?:$|$)/mg\n\n// Parse src into an Object\nfunction parse (src) {\n  const obj = {}\n\n  // Convert buffer to string\n  let lines = src.toString()\n\n  // Convert line breaks to same format\n  lines = lines.replace(/\\r\\n?/mg, '\\n')\n\n  let match\n  while ((match = LINE.exec(lines)) != null) {\n    const key = match[1]\n\n    // Default undefined or null to empty string\n    let value = (match[2] || '')\n\n    // Remove whitespace\n    value = value.trim()\n\n    // Check if double quoted\n    const maybeQuote = value[0]\n\n    // Remove surrounding quotes\n    value = value.replace(/^(['\"`])([\\s\\S]*)\\1$/mg, '$2')\n\n    // Expand newlines if double quoted\n    if (maybeQuote === '\"') {\n      value = value.replace(/\\\\n/g, '\\n')\n      value = value.replace(/\\\\r/g, '\\r')\n    }\n\n    // Add to object\n    obj[key] = value\n  }\n\n  return obj\n}\n\nfunction _parseVault (options) {\n  options = options || {}\n\n  const vaultPath = _vaultPath(options)\n  options.path = vaultPath // parse .env.vault\n  const result = DotenvModule.configDotenv(options)\n  if (!result.parsed) {\n    const err = new Error(`MISSING_DATA: Cannot parse ${vaultPath} for an unknown reason`)\n    err.code = 'MISSING_DATA'\n    throw err\n  }\n\n  // handle scenario for comma separated keys - for use with key rotation\n  // example: DOTENV_KEY=\"dotenv://:key_1234@dotenvx.com/vault/.env.vault?environment=prod,dotenv://:key_7890@dotenvx.com/vault/.env.vault?environment=prod\"\n  const keys = _dotenvKey(options).split(',')\n  const length = keys.length\n\n  let decrypted\n  for (let i = 0; i < length; i++) {\n    try {\n      // Get full key\n      const key = keys[i].trim()\n\n      // Get instructions for decrypt\n      const attrs = _instructions(result, key)\n\n      // Decrypt\n      decrypted = DotenvModule.decrypt(attrs.ciphertext, attrs.key)\n\n      break\n    } catch (error) {\n      // last key\n      if (i + 1 >= length) {\n        throw error\n      }\n      // try next key\n    }\n  }\n\n  // Parse decrypted .env string\n  return DotenvModule.parse(decrypted)\n}\n\nfunction _warn (message) {\n  console.error(`[dotenv@${version}][WARN] ${message}`)\n}\n\nfunction _debug (message) {\n  console.log(`[dotenv@${version}][DEBUG] ${message}`)\n}\n\nfunction _log (message) {\n  console.log(`[dotenv@${version}] ${message}`)\n}\n\nfunction _dotenvKey (options) {\n  // prioritize developer directly setting options.DOTENV_KEY\n  if (options && options.DOTENV_KEY && options.DOTENV_KEY.length > 0) {\n    return options.DOTENV_KEY\n  }\n\n  // secondary infra already contains a DOTENV_KEY environment variable\n  if (process.env.DOTENV_KEY && process.env.DOTENV_KEY.length > 0) {\n    return process.env.DOTENV_KEY\n  }\n\n  // fallback to empty string\n  return ''\n}\n\nfunction _instructions (result, dotenvKey) {\n  // Parse DOTENV_KEY. Format is a URI\n  let uri\n  try {\n    uri = new URL(dotenvKey)\n  } catch (error) {\n    if (error.code === 'ERR_INVALID_URL') {\n      const err = new Error('INVALID_DOTENV_KEY: Wrong format. Must be in valid uri format like dotenv://:key_1234@dotenvx.com/vault/.env.vault?environment=development')\n      err.code = 'INVALID_DOTENV_KEY'\n      throw err\n    }\n\n    throw error\n  }\n\n  // Get decrypt key\n  const key = uri.password\n  if (!key) {\n    const err = new Error('INVALID_DOTENV_KEY: Missing key part')\n    err.code = 'INVALID_DOTENV_KEY'\n    throw err\n  }\n\n  // Get environment\n  const environment = uri.searchParams.get('environment')\n  if (!environment) {\n    const err = new Error('INVALID_DOTENV_KEY: Missing environment part')\n    err.code = 'INVALID_DOTENV_KEY'\n    throw err\n  }\n\n  // Get ciphertext payload\n  const environmentKey = `DOTENV_VAULT_${environment.toUpperCase()}`\n  const ciphertext = result.parsed[environmentKey] // DOTENV_VAULT_PRODUCTION\n  if (!ciphertext) {\n    const err = new Error(`NOT_FOUND_DOTENV_ENVIRONMENT: Cannot locate environment ${environmentKey} in your .env.vault file.`)\n    err.code = 'NOT_FOUND_DOTENV_ENVIRONMENT'\n    throw err\n  }\n\n  return { ciphertext, key }\n}\n\nfunction _vaultPath (options) {\n  let possibleVaultPath = null\n\n  if (options && options.path && options.path.length > 0) {\n    if (Array.isArray(options.path)) {\n      for (const filepath of options.path) {\n        if (fs.existsSync(filepath)) {\n          possibleVaultPath = filepath.endsWith('.vault') ? filepath : `${filepath}.vault`\n        }\n      }\n    } else {\n      possibleVaultPath = options.path.endsWith('.vault') ? options.path : `${options.path}.vault`\n    }\n  } else {\n    possibleVaultPath = path.resolve(process.cwd(), '.env.vault')\n  }\n\n  if (fs.existsSync(possibleVaultPath)) {\n    return possibleVaultPath\n  }\n\n  return null\n}\n\nfunction _resolveHome (envPath) {\n  return envPath[0] === '~' ? path.join(os.homedir(), envPath.slice(1)) : envPath\n}\n\nfunction _configVault (options) {\n  const debug = parseBoolean(process.env.DOTENV_CONFIG_DEBUG || (options && options.debug))\n  const quiet = parseBoolean(process.env.DOTENV_CONFIG_QUIET || (options && options.quiet))\n\n  if (debug || !quiet) {\n    _log('Loading env from encrypted .env.vault')\n  }\n\n  const parsed = DotenvModule._parseVault(options)\n\n  let processEnv = process.env\n  if (options && options.processEnv != null) {\n    processEnv = options.processEnv\n  }\n\n  DotenvModule.populate(processEnv, parsed, options)\n\n  return { parsed }\n}\n\nfunction configDotenv (options) {\n  const dotenvPath = path.resolve(process.cwd(), '.env')\n  let encoding = 'utf8'\n  let processEnv = process.env\n  if (options && options.processEnv != null) {\n    processEnv = options.processEnv\n  }\n  let debug = parseBoolean(processEnv.DOTENV_CONFIG_DEBUG || (options && options.debug))\n  let quiet = parseBoolean(processEnv.DOTENV_CONFIG_QUIET || (options && options.quiet))\n\n  if (options && options.encoding) {\n    encoding = options.encoding\n  } else {\n    if (debug) {\n      _debug('No encoding is specified. UTF-8 is used by default')\n    }\n  }\n\n  let optionPaths = [dotenvPath] // default, look for .env\n  if (options && options.path) {\n    if (!Array.isArray(options.path)) {\n      optionPaths = [_resolveHome(options.path)]\n    } else {\n      optionPaths = [] // reset default\n      for (const filepath of options.path) {\n        optionPaths.push(_resolveHome(filepath))\n      }\n    }\n  }\n\n  // Build the parsed data in a temporary object (because we need to return it).  Once we have the final\n  // parsed data, we will combine it with process.env (or options.processEnv if provided).\n  let lastError\n  const parsedAll = {}\n  for (const path of optionPaths) {\n    try {\n      // Specifying an encoding returns a string instead of a buffer\n      const parsed = DotenvModule.parse(fs.readFileSync(path, { encoding }))\n\n      DotenvModule.populate(parsedAll, parsed, options)\n    } catch (e) {\n      if (debug) {\n        _debug(`Failed to load ${path} ${e.message}`)\n      }\n      lastError = e\n    }\n  }\n\n  const populated = DotenvModule.populate(processEnv, parsedAll, options)\n\n  // handle user settings DOTENV_CONFIG_ options inside .env file(s)\n  debug = parseBoolean(processEnv.DOTENV_CONFIG_DEBUG || debug)\n  quiet = parseBoolean(processEnv.DOTENV_CONFIG_QUIET || quiet)\n\n  if (debug || !quiet) {\n    const keysCount = Object.keys(populated).length\n    const shortPaths = []\n    for (const filePath of optionPaths) {\n      try {\n        const relative = path.relative(process.cwd(), filePath)\n        shortPaths.push(relative)\n      } catch (e) {\n        if (debug) {\n          _debug(`Failed to load ${filePath} ${e.message}`)\n        }\n        lastError = e\n      }\n    }\n\n    _log(`injecting env (${keysCount}) from ${shortPaths.join(',')} ${dim(`-- tip: ${_getRandomTip()}`)}`)\n  }\n\n  if (lastError) {\n    return { parsed: parsedAll, error: lastError }\n  } else {\n    return { parsed: parsedAll }\n  }\n}\n\n// Populates process.env from .env file\nfunction config (options) {\n  // fallback to original dotenv if DOTENV_KEY is not set\n  if (_dotenvKey(options).length === 0) {\n    return DotenvModule.configDotenv(options)\n  }\n\n  const vaultPath = _vaultPath(options)\n\n  // dotenvKey exists but .env.vault file does not exist\n  if (!vaultPath) {\n    _warn(`You set DOTENV_KEY but you are missing a .env.vault file at ${vaultPath}. Did you forget to build it?`)\n\n    return DotenvModule.configDotenv(options)\n  }\n\n  return DotenvModule._configVault(options)\n}\n\nfunction decrypt (encrypted, keyStr) {\n  const key = Buffer.from(keyStr.slice(-64), 'hex')\n  let ciphertext = Buffer.from(encrypted, 'base64')\n\n  const nonce = ciphertext.subarray(0, 12)\n  const authTag = ciphertext.subarray(-16)\n  ciphertext = ciphertext.subarray(12, -16)\n\n  try {\n    const aesgcm = crypto.createDecipheriv('aes-256-gcm', key, nonce)\n    aesgcm.setAuthTag(authTag)\n    return `${aesgcm.update(ciphertext)}${aesgcm.final()}`\n  } catch (error) {\n    const isRange = error instanceof RangeError\n    const invalidKeyLength = error.message === 'Invalid key length'\n    const decryptionFailed = error.message === 'Unsupported state or unable to authenticate data'\n\n    if (isRange || invalidKeyLength) {\n      const err = new Error('INVALID_DOTENV_KEY: It must be 64 characters long (or more)')\n      err.code = 'INVALID_DOTENV_KEY'\n      throw err\n    } else if (decryptionFailed) {\n      const err = new Error('DECRYPTION_FAILED: Please check your DOTENV_KEY')\n      err.code = 'DECRYPTION_FAILED'\n      throw err\n    } else {\n      throw error\n    }\n  }\n}\n\n// Populate process.env with parsed values\nfunction populate (processEnv, parsed, options = {}) {\n  const debug = Boolean(options && options.debug)\n  const override = Boolean(options && options.override)\n  const populated = {}\n\n  if (typeof parsed !== 'object') {\n    const err = new Error('OBJECT_REQUIRED: Please check the processEnv argument being passed to populate')\n    err.code = 'OBJECT_REQUIRED'\n    throw err\n  }\n\n  // Set process.env\n  for (const key of Object.keys(parsed)) {\n    if (Object.prototype.hasOwnProperty.call(processEnv, key)) {\n      if (override === true) {\n        processEnv[key] = parsed[key]\n        populated[key] = parsed[key]\n      }\n\n      if (debug) {\n        if (override === true) {\n          _debug(`\"${key}\" is already defined and WAS overwritten`)\n        } else {\n          _debug(`\"${key}\" is already defined and was NOT overwritten`)\n        }\n      }\n    } else {\n      processEnv[key] = parsed[key]\n      populated[key] = parsed[key]\n    }\n  }\n\n  return populated\n}\n\nconst DotenvModule = {\n  configDotenv,\n  _configVault,\n  _parseVault,\n  config,\n  decrypt,\n  parse,\n  populate\n}\n\nmodule.exports.configDotenv = DotenvModule.configDotenv\nmodule.exports._configVault = DotenvModule._configVault\nmodule.exports._parseVault = DotenvModule._parseVault\nmodule.exports.config = DotenvModule.config\nmodule.exports.decrypt = DotenvModule.decrypt\nmodule.exports.parse = DotenvModule.parse\nmodule.exports.populate = DotenvModule.populate\n\nmodule.exports = DotenvModule\n\n\n//# sourceURL=webpack://onda-app-dev/./node_modules/dotenv/lib/main.js?\n}");

/***/ }),

/***/ "./node_modules/dotenv/package.json":
/*!******************************************!*\
  !*** ./node_modules/dotenv/package.json ***!
  \******************************************/
/***/ ((module) => {

"use strict";
eval("{module.exports = /*#__PURE__*/JSON.parse('{\"name\":\"dotenv\",\"version\":\"17.2.3\",\"description\":\"Loads environment variables from .env file\",\"main\":\"lib/main.js\",\"types\":\"lib/main.d.ts\",\"exports\":{\".\":{\"types\":\"./lib/main.d.ts\",\"require\":\"./lib/main.js\",\"default\":\"./lib/main.js\"},\"./config\":\"./config.js\",\"./config.js\":\"./config.js\",\"./lib/env-options\":\"./lib/env-options.js\",\"./lib/env-options.js\":\"./lib/env-options.js\",\"./lib/cli-options\":\"./lib/cli-options.js\",\"./lib/cli-options.js\":\"./lib/cli-options.js\",\"./package.json\":\"./package.json\"},\"scripts\":{\"dts-check\":\"tsc --project tests/types/tsconfig.json\",\"lint\":\"standard\",\"pretest\":\"npm run lint && npm run dts-check\",\"test\":\"tap run tests/**/*.js --allow-empty-coverage --disable-coverage --timeout=60000\",\"test:coverage\":\"tap run tests/**/*.js --show-full-coverage --timeout=60000 --coverage-report=text --coverage-report=lcov\",\"prerelease\":\"npm test\",\"release\":\"standard-version\"},\"repository\":{\"type\":\"git\",\"url\":\"git://github.com/motdotla/dotenv.git\"},\"homepage\":\"https://github.com/motdotla/dotenv#readme\",\"funding\":\"https://dotenvx.com\",\"keywords\":[\"dotenv\",\"env\",\".env\",\"environment\",\"variables\",\"config\",\"settings\"],\"readmeFilename\":\"README.md\",\"license\":\"BSD-2-Clause\",\"devDependencies\":{\"@types/node\":\"^18.11.3\",\"decache\":\"^4.6.2\",\"sinon\":\"^14.0.1\",\"standard\":\"^17.0.0\",\"standard-version\":\"^9.5.0\",\"tap\":\"^19.2.0\",\"typescript\":\"^4.8.4\"},\"engines\":{\"node\":\">=12\"},\"browser\":{\"fs\":false}}');\n\n//# sourceURL=webpack://onda-app-dev/./node_modules/dotenv/package.json?\n}");

/***/ }),

/***/ "./node_modules/node-cron/dist/cjs/create-id.js":
/*!******************************************************!*\
  !*** ./node_modules/node-cron/dist/cjs/create-id.js ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("{\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.createID = createID;\nconst node_crypto_1 = __importDefault(__webpack_require__(/*! node:crypto */ \"node:crypto\"));\nfunction createID(prefix = '', length = 16) {\n    const charset = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';\n    const values = node_crypto_1.default.randomBytes(length);\n    const id = Array.from(values, v => charset[v % charset.length]).join('');\n    return prefix ? `${prefix}-${id}` : id;\n}\n//# sourceMappingURL=create-id.js.map\n\n//# sourceURL=webpack://onda-app-dev/./node_modules/node-cron/dist/cjs/create-id.js?\n}");

/***/ }),

/***/ "./node_modules/node-cron/dist/cjs/logger.js":
/*!***************************************************!*\
  !*** ./node_modules/node-cron/dist/cjs/logger.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst levelColors = {\n    INFO: '\\x1b[36m',\n    WARN: '\\x1b[33m',\n    ERROR: '\\x1b[31m',\n    DEBUG: '\\x1b[35m',\n};\nconst GREEN = '\\x1b[32m';\nconst RESET = '\\x1b[0m';\nfunction log(level, message, extra) {\n    const timestamp = new Date().toISOString();\n    const color = levelColors[level] ?? '';\n    const prefix = `[${timestamp}] [PID: ${process.pid}] ${GREEN}[NODE-CRON]${GREEN} ${color}[${level}]${RESET}`;\n    const output = `${prefix} ${message}`;\n    switch (level) {\n        case 'ERROR':\n            console.error(output, extra ?? '');\n            break;\n        case 'DEBUG':\n            console.debug(output, extra ?? '');\n            break;\n        case 'WARN':\n            console.warn(output);\n            break;\n        case 'INFO':\n        default:\n            console.info(output);\n            break;\n    }\n}\nconst logger = {\n    info(message) {\n        log('INFO', message);\n    },\n    warn(message) {\n        log('WARN', message);\n    },\n    error(message, err) {\n        if (message instanceof Error) {\n            log('ERROR', message.message, message);\n        }\n        else {\n            log('ERROR', message, err);\n        }\n    },\n    debug(message, err) {\n        if (message instanceof Error) {\n            log('DEBUG', message.message, message);\n        }\n        else {\n            log('DEBUG', message, err);\n        }\n    },\n};\nexports[\"default\"] = logger;\n//# sourceMappingURL=logger.js.map\n\n//# sourceURL=webpack://onda-app-dev/./node_modules/node-cron/dist/cjs/logger.js?\n}");

/***/ }),

/***/ "./node_modules/node-cron/dist/cjs/node-cron.js":
/*!******************************************************!*\
  !*** ./node_modules/node-cron/dist/cjs/node-cron.js ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("{\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.nodeCron = exports.getTask = exports.getTasks = void 0;\nexports.schedule = schedule;\nexports.createTask = createTask;\nexports.solvePath = solvePath;\nexports.validate = validate;\nconst inline_scheduled_task_1 = __webpack_require__(/*! ./tasks/inline-scheduled-task */ \"./node_modules/node-cron/dist/cjs/tasks/inline-scheduled-task.js\");\nconst task_registry_1 = __webpack_require__(/*! ./task-registry */ \"./node_modules/node-cron/dist/cjs/task-registry.js\");\nconst pattern_validation_1 = __importDefault(__webpack_require__(/*! ./pattern/validation/pattern-validation */ \"./node_modules/node-cron/dist/cjs/pattern/validation/pattern-validation.js\"));\nconst background_scheduled_task_1 = __importDefault(__webpack_require__(/*! ./tasks/background-scheduled-task/background-scheduled-task */ \"./node_modules/node-cron/dist/cjs/tasks/background-scheduled-task/background-scheduled-task.js\"));\nconst path_1 = __importDefault(__webpack_require__(/*! path */ \"path\"));\nconst url_1 = __webpack_require__(/*! url */ \"url\");\nconst registry = new task_registry_1.TaskRegistry();\nfunction schedule(expression, func, options) {\n    const task = createTask(expression, func, options);\n    task.start();\n    return task;\n}\nfunction createTask(expression, func, options) {\n    let task;\n    if (func instanceof Function) {\n        task = new inline_scheduled_task_1.InlineScheduledTask(expression, func, options);\n    }\n    else {\n        const taskPath = solvePath(func);\n        task = new background_scheduled_task_1.default(expression, taskPath, options);\n    }\n    registry.add(task);\n    return task;\n}\nfunction solvePath(filePath) {\n    if (path_1.default.isAbsolute(filePath))\n        return (0, url_1.pathToFileURL)(filePath).href;\n    if (filePath.startsWith('file://'))\n        return filePath;\n    const stackLines = new Error().stack?.split('\\n');\n    if (stackLines) {\n        stackLines?.shift();\n        const callerLine = stackLines?.find((line) => { return line.indexOf(__filename) === -1; });\n        const match = callerLine?.match(/(file:\\/\\/)?(((\\/?)(\\w:))?([/\\\\].+)):\\d+:\\d+/);\n        if (match) {\n            const dir = `${match[5] ?? \"\"}${path_1.default.dirname(match[6])}`;\n            return (0, url_1.pathToFileURL)(path_1.default.resolve(dir, filePath)).href;\n        }\n    }\n    throw new Error(`Could not locate task file ${filePath}`);\n}\nfunction validate(expression) {\n    try {\n        (0, pattern_validation_1.default)(expression);\n        return true;\n    }\n    catch (e) {\n        return false;\n    }\n}\nexports.getTasks = registry.all;\nexports.getTask = registry.get;\nexports.nodeCron = {\n    schedule,\n    createTask,\n    validate,\n    getTasks: exports.getTasks,\n    getTask: exports.getTask,\n};\nexports[\"default\"] = exports.nodeCron;\n//# sourceMappingURL=node-cron.js.map\n\n//# sourceURL=webpack://onda-app-dev/./node_modules/node-cron/dist/cjs/node-cron.js?\n}");

/***/ }),

/***/ "./node_modules/node-cron/dist/cjs/pattern/convertion/asterisk-to-range-conversion.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/node-cron/dist/cjs/pattern/convertion/asterisk-to-range-conversion.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports[\"default\"] = (() => {\n    function convertAsterisk(expression, replecement) {\n        if (expression.indexOf('*') !== -1) {\n            return expression.replace('*', replecement);\n        }\n        return expression;\n    }\n    function convertAsterisksToRanges(expressions) {\n        expressions[0] = convertAsterisk(expressions[0], '0-59');\n        expressions[1] = convertAsterisk(expressions[1], '0-59');\n        expressions[2] = convertAsterisk(expressions[2], '0-23');\n        expressions[3] = convertAsterisk(expressions[3], '1-31');\n        expressions[4] = convertAsterisk(expressions[4], '1-12');\n        expressions[5] = convertAsterisk(expressions[5], '0-6');\n        return expressions;\n    }\n    return convertAsterisksToRanges;\n})();\n//# sourceMappingURL=asterisk-to-range-conversion.js.map\n\n//# sourceURL=webpack://onda-app-dev/./node_modules/node-cron/dist/cjs/pattern/convertion/asterisk-to-range-conversion.js?\n}");

/***/ }),

/***/ "./node_modules/node-cron/dist/cjs/pattern/convertion/index.js":
/*!*********************************************************************!*\
  !*** ./node_modules/node-cron/dist/cjs/pattern/convertion/index.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("{\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst month_names_conversion_1 = __importDefault(__webpack_require__(/*! ./month-names-conversion */ \"./node_modules/node-cron/dist/cjs/pattern/convertion/month-names-conversion.js\"));\nconst week_day_names_conversion_1 = __importDefault(__webpack_require__(/*! ./week-day-names-conversion */ \"./node_modules/node-cron/dist/cjs/pattern/convertion/week-day-names-conversion.js\"));\nconst asterisk_to_range_conversion_1 = __importDefault(__webpack_require__(/*! ./asterisk-to-range-conversion */ \"./node_modules/node-cron/dist/cjs/pattern/convertion/asterisk-to-range-conversion.js\"));\nconst range_conversion_1 = __importDefault(__webpack_require__(/*! ./range-conversion */ \"./node_modules/node-cron/dist/cjs/pattern/convertion/range-conversion.js\"));\nexports[\"default\"] = (() => {\n    function appendSeccondExpression(expressions) {\n        if (expressions.length === 5) {\n            return ['0'].concat(expressions);\n        }\n        return expressions;\n    }\n    function removeSpaces(str) {\n        return str.replace(/\\s{2,}/g, ' ').trim();\n    }\n    function normalizeIntegers(expressions) {\n        for (let i = 0; i < expressions.length; i++) {\n            const numbers = expressions[i].split(',');\n            for (let j = 0; j < numbers.length; j++) {\n                numbers[j] = parseInt(numbers[j]);\n            }\n            expressions[i] = numbers;\n        }\n        return expressions;\n    }\n    function interprete(expression) {\n        let expressions = removeSpaces(`${expression}`).split(' ');\n        expressions = appendSeccondExpression(expressions);\n        expressions[4] = (0, month_names_conversion_1.default)(expressions[4]);\n        expressions[5] = (0, week_day_names_conversion_1.default)(expressions[5]);\n        expressions = (0, asterisk_to_range_conversion_1.default)(expressions);\n        expressions = (0, range_conversion_1.default)(expressions);\n        expressions = normalizeIntegers(expressions);\n        return expressions;\n    }\n    return interprete;\n})();\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://onda-app-dev/./node_modules/node-cron/dist/cjs/pattern/convertion/index.js?\n}");

/***/ }),

/***/ "./node_modules/node-cron/dist/cjs/pattern/convertion/month-names-conversion.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/node-cron/dist/cjs/pattern/convertion/month-names-conversion.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports[\"default\"] = (() => {\n    const months = ['january', 'february', 'march', 'april', 'may', 'june', 'july',\n        'august', 'september', 'october', 'november', 'december'];\n    const shortMonths = ['jan', 'feb', 'mar', 'apr', 'may', 'jun', 'jul', 'aug',\n        'sep', 'oct', 'nov', 'dec'];\n    function convertMonthName(expression, items) {\n        for (let i = 0; i < items.length; i++) {\n            expression = expression.replace(new RegExp(items[i], 'gi'), i + 1);\n        }\n        return expression;\n    }\n    function interprete(monthExpression) {\n        monthExpression = convertMonthName(monthExpression, months);\n        monthExpression = convertMonthName(monthExpression, shortMonths);\n        return monthExpression;\n    }\n    return interprete;\n})();\n//# sourceMappingURL=month-names-conversion.js.map\n\n//# sourceURL=webpack://onda-app-dev/./node_modules/node-cron/dist/cjs/pattern/convertion/month-names-conversion.js?\n}");

/***/ }),

/***/ "./node_modules/node-cron/dist/cjs/pattern/convertion/range-conversion.js":
/*!********************************************************************************!*\
  !*** ./node_modules/node-cron/dist/cjs/pattern/convertion/range-conversion.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports[\"default\"] = (() => {\n    function replaceWithRange(expression, text, init, end, stepTxt) {\n        const step = parseInt(stepTxt);\n        const numbers = [];\n        let last = parseInt(end);\n        let first = parseInt(init);\n        if (first > last) {\n            last = parseInt(init);\n            first = parseInt(end);\n        }\n        for (let i = first; i <= last; i += step) {\n            numbers.push(i);\n        }\n        return expression.replace(new RegExp(text, 'i'), numbers.join());\n    }\n    function convertRange(expression) {\n        const rangeRegEx = /(\\d+)-(\\d+)(\\/(\\d+)|)/;\n        let match = rangeRegEx.exec(expression);\n        while (match !== null && match.length > 0) {\n            expression = replaceWithRange(expression, match[0], match[1], match[2], match[4] || '1');\n            match = rangeRegEx.exec(expression);\n        }\n        return expression;\n    }\n    function convertAllRanges(expressions) {\n        for (let i = 0; i < expressions.length; i++) {\n            expressions[i] = convertRange(expressions[i]);\n        }\n        return expressions;\n    }\n    return convertAllRanges;\n})();\n//# sourceMappingURL=range-conversion.js.map\n\n//# sourceURL=webpack://onda-app-dev/./node_modules/node-cron/dist/cjs/pattern/convertion/range-conversion.js?\n}");

/***/ }),

/***/ "./node_modules/node-cron/dist/cjs/pattern/convertion/week-day-names-conversion.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/node-cron/dist/cjs/pattern/convertion/week-day-names-conversion.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports[\"default\"] = (() => {\n    const weekDays = ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday',\n        'friday', 'saturday'];\n    const shortWeekDays = ['sun', 'mon', 'tue', 'wed', 'thu', 'fri', 'sat'];\n    function convertWeekDayName(expression, items) {\n        for (let i = 0; i < items.length; i++) {\n            expression = expression.replace(new RegExp(items[i], 'gi'), i);\n        }\n        return expression;\n    }\n    function convertWeekDays(expression) {\n        expression = expression.replace('7', '0');\n        expression = convertWeekDayName(expression, weekDays);\n        return convertWeekDayName(expression, shortWeekDays);\n    }\n    return convertWeekDays;\n})();\n//# sourceMappingURL=week-day-names-conversion.js.map\n\n//# sourceURL=webpack://onda-app-dev/./node_modules/node-cron/dist/cjs/pattern/convertion/week-day-names-conversion.js?\n}");

/***/ }),

/***/ "./node_modules/node-cron/dist/cjs/pattern/validation/pattern-validation.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/node-cron/dist/cjs/pattern/validation/pattern-validation.js ***!
  \**********************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("{\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst index_1 = __importDefault(__webpack_require__(/*! ../convertion/index */ \"./node_modules/node-cron/dist/cjs/pattern/convertion/index.js\"));\nconst validationRegex = /^(?:\\d+|\\*|\\*\\/\\d+)$/;\nfunction isValidExpression(expression, min, max) {\n    const options = expression;\n    for (const option of options) {\n        const optionAsInt = parseInt(option, 10);\n        if ((!Number.isNaN(optionAsInt) &&\n            (optionAsInt < min || optionAsInt > max)) ||\n            !validationRegex.test(option))\n            return false;\n    }\n    return true;\n}\nfunction isInvalidSecond(expression) {\n    return !isValidExpression(expression, 0, 59);\n}\nfunction isInvalidMinute(expression) {\n    return !isValidExpression(expression, 0, 59);\n}\nfunction isInvalidHour(expression) {\n    return !isValidExpression(expression, 0, 23);\n}\nfunction isInvalidDayOfMonth(expression) {\n    return !isValidExpression(expression, 1, 31);\n}\nfunction isInvalidMonth(expression) {\n    return !isValidExpression(expression, 1, 12);\n}\nfunction isInvalidWeekDay(expression) {\n    return !isValidExpression(expression, 0, 7);\n}\nfunction validateFields(patterns, executablePatterns) {\n    if (isInvalidSecond(executablePatterns[0]))\n        throw new Error(`${patterns[0]} is a invalid expression for second`);\n    if (isInvalidMinute(executablePatterns[1]))\n        throw new Error(`${patterns[1]} is a invalid expression for minute`);\n    if (isInvalidHour(executablePatterns[2]))\n        throw new Error(`${patterns[2]} is a invalid expression for hour`);\n    if (isInvalidDayOfMonth(executablePatterns[3]))\n        throw new Error(`${patterns[3]} is a invalid expression for day of month`);\n    if (isInvalidMonth(executablePatterns[4]))\n        throw new Error(`${patterns[4]} is a invalid expression for month`);\n    if (isInvalidWeekDay(executablePatterns[5]))\n        throw new Error(`${patterns[5]} is a invalid expression for week day`);\n}\nfunction validate(pattern) {\n    if (typeof pattern !== 'string')\n        throw new TypeError('pattern must be a string!');\n    const patterns = pattern.split(' ');\n    const executablePatterns = (0, index_1.default)(pattern);\n    if (patterns.length === 5)\n        patterns.unshift('0');\n    validateFields(patterns, executablePatterns);\n}\nexports[\"default\"] = validate;\n//# sourceMappingURL=pattern-validation.js.map\n\n//# sourceURL=webpack://onda-app-dev/./node_modules/node-cron/dist/cjs/pattern/validation/pattern-validation.js?\n}");

/***/ }),

/***/ "./node_modules/node-cron/dist/cjs/promise/tracked-promise.js":
/*!********************************************************************!*\
  !*** ./node_modules/node-cron/dist/cjs/promise/tracked-promise.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.TrackedPromise = void 0;\nclass TrackedPromise {\n    promise;\n    error;\n    state;\n    value;\n    constructor(executor) {\n        this.state = 'pending';\n        this.promise = new Promise((resolve, reject) => {\n            executor((value) => {\n                this.state = 'fulfilled';\n                this.value = value;\n                resolve(value);\n            }, (error) => {\n                this.state = 'rejected';\n                this.error = error;\n                reject(error);\n            });\n        });\n    }\n    getPromise() {\n        return this.promise;\n    }\n    getState() {\n        return this.state;\n    }\n    isPending() {\n        return this.state === 'pending';\n    }\n    isFulfilled() {\n        return this.state === 'fulfilled';\n    }\n    isRejected() {\n        return this.state === 'rejected';\n    }\n    getValue() {\n        return this.value;\n    }\n    getError() {\n        return this.error;\n    }\n    then(onfulfilled, onrejected) {\n        return this.promise.then(onfulfilled, onrejected);\n    }\n    catch(onrejected) {\n        return this.promise.catch(onrejected);\n    }\n    finally(onfinally) {\n        return this.promise.finally(onfinally);\n    }\n}\nexports.TrackedPromise = TrackedPromise;\n//# sourceMappingURL=tracked-promise.js.map\n\n//# sourceURL=webpack://onda-app-dev/./node_modules/node-cron/dist/cjs/promise/tracked-promise.js?\n}");

/***/ }),

/***/ "./node_modules/node-cron/dist/cjs/scheduler/runner.js":
/*!*************************************************************!*\
  !*** ./node_modules/node-cron/dist/cjs/scheduler/runner.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("{\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Runner = void 0;\nconst create_id_1 = __webpack_require__(/*! ../create-id */ \"./node_modules/node-cron/dist/cjs/create-id.js\");\nconst logger_1 = __importDefault(__webpack_require__(/*! ../logger */ \"./node_modules/node-cron/dist/cjs/logger.js\"));\nconst tracked_promise_1 = __webpack_require__(/*! ../promise/tracked-promise */ \"./node_modules/node-cron/dist/cjs/promise/tracked-promise.js\");\nfunction emptyOnFn() { }\n;\nfunction emptyHookFn() { return true; }\n;\nfunction defaultOnError(date, error) {\n    logger_1.default.error('Task failed with error!', error);\n}\nclass Runner {\n    timeMatcher;\n    onMatch;\n    noOverlap;\n    maxExecutions;\n    maxRandomDelay;\n    runCount;\n    running;\n    heartBeatTimeout;\n    onMissedExecution;\n    onOverlap;\n    onError;\n    beforeRun;\n    onFinished;\n    onMaxExecutions;\n    constructor(timeMatcher, onMatch, options) {\n        this.timeMatcher = timeMatcher;\n        this.onMatch = onMatch;\n        this.noOverlap = options == undefined || options.noOverlap === undefined ? false : options.noOverlap;\n        this.maxExecutions = options?.maxExecutions;\n        this.maxRandomDelay = options?.maxRandomDelay || 0;\n        this.onMissedExecution = options?.onMissedExecution || emptyOnFn;\n        this.onOverlap = options?.onOverlap || emptyOnFn;\n        this.onError = options?.onError || defaultOnError;\n        this.onFinished = options?.onFinished || emptyHookFn;\n        this.beforeRun = options?.beforeRun || emptyHookFn;\n        this.onMaxExecutions = options?.onMaxExecutions || emptyOnFn;\n        this.runCount = 0;\n        this.running = false;\n    }\n    start() {\n        this.running = true;\n        let lastExecution;\n        let expectedNextExecution;\n        const scheduleNextHeartBeat = (currentDate) => {\n            if (this.running) {\n                clearTimeout(this.heartBeatTimeout);\n                this.heartBeatTimeout = setTimeout(heartBeat, getDelay(this.timeMatcher, currentDate));\n            }\n        };\n        const runTask = (date) => {\n            return new Promise(async (resolve) => {\n                const execution = {\n                    id: (0, create_id_1.createID)('exec'),\n                    reason: 'scheduled'\n                };\n                const shouldExecute = await this.beforeRun(date, execution);\n                const randomDelay = Math.floor(Math.random() * this.maxRandomDelay);\n                if (shouldExecute) {\n                    setTimeout(async () => {\n                        try {\n                            this.runCount++;\n                            execution.startedAt = new Date();\n                            const result = await this.onMatch(date, execution);\n                            execution.finishedAt = new Date();\n                            execution.result = result;\n                            this.onFinished(date, execution);\n                            if (this.maxExecutions && this.runCount >= this.maxExecutions) {\n                                this.onMaxExecutions(date);\n                                this.stop();\n                            }\n                        }\n                        catch (error) {\n                            execution.finishedAt = new Date();\n                            execution.error = error;\n                            this.onError(date, error, execution);\n                        }\n                        resolve(true);\n                    }, randomDelay);\n                }\n            });\n        };\n        const checkAndRun = (date) => {\n            return new tracked_promise_1.TrackedPromise(async (resolve, reject) => {\n                try {\n                    if (this.timeMatcher.match(date)) {\n                        await runTask(date);\n                    }\n                    resolve(true);\n                }\n                catch (err) {\n                    reject(err);\n                }\n            });\n        };\n        const heartBeat = async () => {\n            const currentDate = nowWithoutMs();\n            if (expectedNextExecution && expectedNextExecution.getTime() < currentDate.getTime()) {\n                while (expectedNextExecution.getTime() < currentDate.getTime()) {\n                    logger_1.default.warn(`missed execution at ${expectedNextExecution}! Possible blocking IO or high CPU user at the same process used by node-cron.`);\n                    expectedNextExecution = this.timeMatcher.getNextMatch(expectedNextExecution);\n                    runAsync(this.onMissedExecution, expectedNextExecution, defaultOnError);\n                }\n            }\n            if (lastExecution && lastExecution.getState() === 'pending') {\n                runAsync(this.onOverlap, currentDate, defaultOnError);\n                if (this.noOverlap) {\n                    logger_1.default.warn('task still running, new execution blocked by overlap prevention!');\n                    expectedNextExecution = this.timeMatcher.getNextMatch(currentDate);\n                    scheduleNextHeartBeat(currentDate);\n                    return;\n                }\n            }\n            lastExecution = checkAndRun(currentDate);\n            expectedNextExecution = this.timeMatcher.getNextMatch(currentDate);\n            scheduleNextHeartBeat(currentDate);\n        };\n        this.heartBeatTimeout = setTimeout(() => {\n            heartBeat();\n        }, getDelay(this.timeMatcher, nowWithoutMs()));\n    }\n    nextRun() {\n        return this.timeMatcher.getNextMatch(new Date());\n    }\n    stop() {\n        this.running = false;\n        if (this.heartBeatTimeout) {\n            clearTimeout(this.heartBeatTimeout);\n            this.heartBeatTimeout = undefined;\n        }\n    }\n    isStarted() {\n        return !!this.heartBeatTimeout && this.running;\n    }\n    isStopped() {\n        return !this.isStarted();\n    }\n    async execute() {\n        const date = new Date();\n        const execution = {\n            id: (0, create_id_1.createID)('exec'),\n            reason: 'invoked'\n        };\n        try {\n            const shouldExecute = await this.beforeRun(date, execution);\n            if (shouldExecute) {\n                this.runCount++;\n                execution.startedAt = new Date();\n                const result = await this.onMatch(date, execution);\n                execution.finishedAt = new Date();\n                execution.result = result;\n                this.onFinished(date, execution);\n            }\n        }\n        catch (error) {\n            execution.finishedAt = new Date();\n            execution.error = error;\n            this.onError(date, error, execution);\n        }\n    }\n}\nexports.Runner = Runner;\nasync function runAsync(fn, date, onError) {\n    try {\n        await fn(date);\n    }\n    catch (error) {\n        onError(date, error);\n    }\n}\nfunction getDelay(timeMatcher, currentDate) {\n    const maxDelay = 86400000;\n    const nextRun = timeMatcher.getNextMatch(currentDate);\n    const now = new Date();\n    const delay = nextRun.getTime() - now.getTime();\n    if (delay > maxDelay) {\n        return maxDelay;\n    }\n    return Math.max(0, delay);\n}\nfunction nowWithoutMs() {\n    const date = new Date();\n    date.setMilliseconds(0);\n    return date;\n}\n//# sourceMappingURL=runner.js.map\n\n//# sourceURL=webpack://onda-app-dev/./node_modules/node-cron/dist/cjs/scheduler/runner.js?\n}");

/***/ }),

/***/ "./node_modules/node-cron/dist/cjs/task-registry.js":
/*!**********************************************************!*\
  !*** ./node_modules/node-cron/dist/cjs/task-registry.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.TaskRegistry = void 0;\nconst tasks = new Map();\nclass TaskRegistry {\n    add(task) {\n        if (this.has(task.id)) {\n            throw Error(`task ${task.id} already registred!`);\n        }\n        tasks.set(task.id, task);\n        task.on('task:destroyed', () => {\n            this.remove(task);\n        });\n    }\n    get(taskId) {\n        return tasks.get(taskId);\n    }\n    remove(task) {\n        if (this.has(task.id)) {\n            task?.destroy();\n            tasks.delete(task.id);\n        }\n    }\n    all() {\n        return tasks;\n    }\n    has(taskId) {\n        return tasks.has(taskId);\n    }\n    killAll() {\n        tasks.forEach(id => this.remove(id));\n    }\n}\nexports.TaskRegistry = TaskRegistry;\n//# sourceMappingURL=task-registry.js.map\n\n//# sourceURL=webpack://onda-app-dev/./node_modules/node-cron/dist/cjs/task-registry.js?\n}");

/***/ }),

/***/ "./node_modules/node-cron/dist/cjs/tasks/background-scheduled-task/background-scheduled-task.js":
/*!******************************************************************************************************!*\
  !*** ./node_modules/node-cron/dist/cjs/tasks/background-scheduled-task/background-scheduled-task.js ***!
  \******************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("{\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst path_1 = __webpack_require__(/*! path */ \"path\");\nconst child_process_1 = __webpack_require__(/*! child_process */ \"child_process\");\nconst create_id_1 = __webpack_require__(/*! ../../create-id */ \"./node_modules/node-cron/dist/cjs/create-id.js\");\nconst stream_1 = __webpack_require__(/*! stream */ \"stream\");\nconst state_machine_1 = __webpack_require__(/*! ../state-machine */ \"./node_modules/node-cron/dist/cjs/tasks/state-machine.js\");\nconst localized_time_1 = __webpack_require__(/*! ../../time/localized-time */ \"./node_modules/node-cron/dist/cjs/time/localized-time.js\");\nconst logger_1 = __importDefault(__webpack_require__(/*! ../../logger */ \"./node_modules/node-cron/dist/cjs/logger.js\"));\nconst time_matcher_1 = __webpack_require__(/*! ../../time/time-matcher */ \"./node_modules/node-cron/dist/cjs/time/time-matcher.js\");\nconst daemonPath = (0, path_1.resolve)(__dirname, 'daemon.js');\nclass TaskEmitter extends stream_1.EventEmitter {\n}\nclass BackgroundScheduledTask {\n    emitter;\n    id;\n    name;\n    cronExpression;\n    taskPath;\n    options;\n    forkProcess;\n    stateMachine;\n    constructor(cronExpression, taskPath, options) {\n        this.cronExpression = cronExpression;\n        this.taskPath = taskPath;\n        this.options = options;\n        this.id = (0, create_id_1.createID)('task');\n        this.name = options?.name || this.id;\n        this.emitter = new TaskEmitter();\n        this.stateMachine = new state_machine_1.StateMachine('stopped');\n        this.on('task:stopped', () => {\n            this.forkProcess?.kill();\n            this.forkProcess = undefined;\n            this.stateMachine.changeState('stopped');\n        });\n        this.on('task:destroyed', () => {\n            this.forkProcess?.kill();\n            this.forkProcess = undefined;\n            this.stateMachine.changeState('destroyed');\n        });\n    }\n    getNextRun() {\n        if (this.stateMachine.state !== 'stopped') {\n            const timeMatcher = new time_matcher_1.TimeMatcher(this.cronExpression, this.options?.timezone);\n            return timeMatcher.getNextMatch(new Date());\n        }\n        return null;\n    }\n    start() {\n        return new Promise((resolve, reject) => {\n            if (this.forkProcess) {\n                return resolve(undefined);\n            }\n            const timeout = setTimeout(() => {\n                reject(new Error('Start operation timed out'));\n            }, 5000);\n            try {\n                this.forkProcess = (0, child_process_1.fork)(daemonPath);\n                this.forkProcess.on('error', (err) => {\n                    clearTimeout(timeout);\n                    reject(new Error(`Error on daemon: ${err.message}`));\n                });\n                this.forkProcess.on('exit', (code, signal) => {\n                    if (code !== 0 && signal !== 'SIGTERM') {\n                        const erro = new Error(`node-cron daemon exited with code ${code || signal}`);\n                        logger_1.default.error(erro);\n                        clearTimeout(timeout);\n                        reject(erro);\n                    }\n                });\n                this.forkProcess.on('message', (message) => {\n                    if (message.jsonError) {\n                        if (message.context?.execution) {\n                            message.context.execution.error = deserializeError(message.jsonError);\n                            delete message.jsonError;\n                        }\n                    }\n                    if (message.context?.task?.state) {\n                        this.stateMachine.changeState(message.context?.task?.state);\n                    }\n                    if (message.context) {\n                        const execution = message.context?.execution;\n                        delete execution?.hasError;\n                        const context = this.createContext(new Date(message.context.date), execution);\n                        this.emitter.emit(message.event, context);\n                    }\n                });\n                this.once('task:started', () => {\n                    this.stateMachine.changeState('idle');\n                    clearTimeout(timeout);\n                    resolve(undefined);\n                });\n                this.forkProcess.send({\n                    command: 'task:start',\n                    path: this.taskPath,\n                    cron: this.cronExpression,\n                    options: this.options\n                });\n            }\n            catch (error) {\n                reject(error);\n            }\n        });\n    }\n    stop() {\n        return new Promise((resolve, reject) => {\n            if (!this.forkProcess) {\n                return resolve(undefined);\n            }\n            const timeoutId = setTimeout(() => {\n                clearTimeout(timeoutId);\n                reject(new Error('Stop operation timed out'));\n            }, 5000);\n            const cleanupAndResolve = () => {\n                clearTimeout(timeoutId);\n                this.off('task:stopped', onStopped);\n                this.forkProcess = undefined;\n                resolve(undefined);\n            };\n            const onStopped = () => {\n                cleanupAndResolve();\n            };\n            this.once('task:stopped', onStopped);\n            this.forkProcess.send({\n                command: 'task:stop'\n            });\n        });\n    }\n    getStatus() {\n        return this.stateMachine.state;\n    }\n    destroy() {\n        return new Promise((resolve, reject) => {\n            if (!this.forkProcess) {\n                return resolve(undefined);\n            }\n            const timeoutId = setTimeout(() => {\n                clearTimeout(timeoutId);\n                reject(new Error('Destroy operation timed out'));\n            }, 5000);\n            const onDestroy = () => {\n                clearTimeout(timeoutId);\n                this.off('task:destroyed', onDestroy);\n                resolve(undefined);\n            };\n            this.once('task:destroyed', onDestroy);\n            this.forkProcess.send({\n                command: 'task:destroy'\n            });\n        });\n    }\n    execute() {\n        return new Promise((resolve, reject) => {\n            if (!this.forkProcess) {\n                return reject(new Error('Cannot execute background task because it hasn\\'t been started yet. Please initialize the task using the start() method before attempting to execute it.'));\n            }\n            const timeoutId = setTimeout(() => {\n                cleanupListeners();\n                reject(new Error('Execution timeout exceeded'));\n            }, 5000);\n            const cleanupListeners = () => {\n                clearTimeout(timeoutId);\n                this.off('execution:finished', onFinished);\n                this.off('execution:failed', onFail);\n            };\n            const onFinished = (context) => {\n                cleanupListeners();\n                resolve(context.execution?.result);\n            };\n            const onFail = (context) => {\n                cleanupListeners();\n                reject(context.execution?.error || new Error('Execution failed without specific error'));\n            };\n            this.once('execution:finished', onFinished);\n            this.once('execution:failed', onFail);\n            this.forkProcess.send({\n                command: 'task:execute'\n            });\n        });\n    }\n    on(event, fun) {\n        this.emitter.on(event, fun);\n    }\n    off(event, fun) {\n        this.emitter.off(event, fun);\n    }\n    once(event, fun) {\n        this.emitter.once(event, fun);\n    }\n    createContext(executionDate, execution) {\n        const localTime = new localized_time_1.LocalizedTime(executionDate, this.options?.timezone);\n        const ctx = {\n            date: localTime.toDate(),\n            dateLocalIso: localTime.toISO(),\n            triggeredAt: new Date(),\n            task: this,\n            execution: execution\n        };\n        return ctx;\n    }\n}\nfunction deserializeError(str) {\n    const data = JSON.parse(str);\n    const Err = globalThis[data.name] || Error;\n    const err = new Err(data.message);\n    if (data.stack) {\n        err.stack = data.stack;\n    }\n    Object.keys(data).forEach(key => {\n        if (!['name', 'message', 'stack'].includes(key)) {\n            err[key] = data[key];\n        }\n    });\n    return err;\n}\nexports[\"default\"] = BackgroundScheduledTask;\n//# sourceMappingURL=background-scheduled-task.js.map\n\n//# sourceURL=webpack://onda-app-dev/./node_modules/node-cron/dist/cjs/tasks/background-scheduled-task/background-scheduled-task.js?\n}");

/***/ }),

/***/ "./node_modules/node-cron/dist/cjs/tasks/inline-scheduled-task.js":
/*!************************************************************************!*\
  !*** ./node_modules/node-cron/dist/cjs/tasks/inline-scheduled-task.js ***!
  \************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("{\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.InlineScheduledTask = void 0;\nconst events_1 = __importDefault(__webpack_require__(/*! events */ \"events\"));\nconst runner_1 = __webpack_require__(/*! ../scheduler/runner */ \"./node_modules/node-cron/dist/cjs/scheduler/runner.js\");\nconst time_matcher_1 = __webpack_require__(/*! ../time/time-matcher */ \"./node_modules/node-cron/dist/cjs/time/time-matcher.js\");\nconst create_id_1 = __webpack_require__(/*! ../create-id */ \"./node_modules/node-cron/dist/cjs/create-id.js\");\nconst state_machine_1 = __webpack_require__(/*! ./state-machine */ \"./node_modules/node-cron/dist/cjs/tasks/state-machine.js\");\nconst logger_1 = __importDefault(__webpack_require__(/*! ../logger */ \"./node_modules/node-cron/dist/cjs/logger.js\"));\nconst localized_time_1 = __webpack_require__(/*! ../time/localized-time */ \"./node_modules/node-cron/dist/cjs/time/localized-time.js\");\nclass TaskEmitter extends events_1.default {\n}\nclass InlineScheduledTask {\n    emitter;\n    cronExpression;\n    timeMatcher;\n    runner;\n    id;\n    name;\n    stateMachine;\n    timezone;\n    constructor(cronExpression, taskFn, options) {\n        this.emitter = new TaskEmitter();\n        this.cronExpression = cronExpression;\n        this.id = (0, create_id_1.createID)('task', 12);\n        this.name = options?.name || this.id;\n        this.timezone = options?.timezone;\n        this.timeMatcher = new time_matcher_1.TimeMatcher(cronExpression, options?.timezone);\n        this.stateMachine = new state_machine_1.StateMachine();\n        const runnerOptions = {\n            timezone: options?.timezone,\n            noOverlap: options?.noOverlap,\n            maxExecutions: options?.maxExecutions,\n            maxRandomDelay: options?.maxRandomDelay,\n            beforeRun: (date, execution) => {\n                if (execution.reason === 'scheduled') {\n                    this.changeState('running');\n                }\n                this.emitter.emit('execution:started', this.createContext(date, execution));\n                return true;\n            },\n            onFinished: (date, execution) => {\n                if (execution.reason === 'scheduled') {\n                    this.changeState('idle');\n                }\n                this.emitter.emit('execution:finished', this.createContext(date, execution));\n                return true;\n            },\n            onError: (date, error, execution) => {\n                logger_1.default.error(error);\n                this.emitter.emit('execution:failed', this.createContext(date, execution));\n                this.changeState('idle');\n            },\n            onOverlap: (date) => {\n                this.emitter.emit('execution:overlap', this.createContext(date));\n            },\n            onMissedExecution: (date) => {\n                this.emitter.emit('execution:missed', this.createContext(date));\n            },\n            onMaxExecutions: (date) => {\n                this.emitter.emit('execution:maxReached', this.createContext(date));\n                this.destroy();\n            }\n        };\n        this.runner = new runner_1.Runner(this.timeMatcher, (date, execution) => {\n            return taskFn(this.createContext(date, execution));\n        }, runnerOptions);\n    }\n    getNextRun() {\n        if (this.stateMachine.state !== 'stopped') {\n            return this.runner.nextRun();\n        }\n        return null;\n    }\n    changeState(state) {\n        if (this.runner.isStarted()) {\n            this.stateMachine.changeState(state);\n        }\n    }\n    start() {\n        if (this.runner.isStopped()) {\n            this.runner.start();\n            this.stateMachine.changeState('idle');\n            this.emitter.emit('task:started', this.createContext(new Date()));\n        }\n    }\n    stop() {\n        if (this.runner.isStarted()) {\n            this.runner.stop();\n            this.stateMachine.changeState('stopped');\n            this.emitter.emit('task:stopped', this.createContext(new Date()));\n        }\n    }\n    getStatus() {\n        return this.stateMachine.state;\n    }\n    destroy() {\n        if (this.stateMachine.state === 'destroyed')\n            return;\n        this.stop();\n        this.stateMachine.changeState('destroyed');\n        this.emitter.emit('task:destroyed', this.createContext(new Date()));\n    }\n    execute() {\n        return new Promise((resolve, reject) => {\n            const onFail = (context) => {\n                this.off('execution:finished', onFail);\n                reject(context.execution?.error);\n            };\n            const onFinished = (context) => {\n                this.off('execution:failed', onFail);\n                resolve(context.execution?.result);\n            };\n            this.once('execution:finished', onFinished);\n            this.once('execution:failed', onFail);\n            this.runner.execute();\n        });\n    }\n    on(event, fun) {\n        this.emitter.on(event, fun);\n    }\n    off(event, fun) {\n        this.emitter.off(event, fun);\n    }\n    once(event, fun) {\n        this.emitter.once(event, fun);\n    }\n    createContext(executionDate, execution) {\n        const localTime = new localized_time_1.LocalizedTime(executionDate, this.timezone);\n        const ctx = {\n            date: localTime.toDate(),\n            dateLocalIso: localTime.toISO(),\n            triggeredAt: new Date(),\n            task: this,\n            execution: execution\n        };\n        return ctx;\n    }\n}\nexports.InlineScheduledTask = InlineScheduledTask;\n//# sourceMappingURL=inline-scheduled-task.js.map\n\n//# sourceURL=webpack://onda-app-dev/./node_modules/node-cron/dist/cjs/tasks/inline-scheduled-task.js?\n}");

/***/ }),

/***/ "./node_modules/node-cron/dist/cjs/tasks/state-machine.js":
/*!****************************************************************!*\
  !*** ./node_modules/node-cron/dist/cjs/tasks/state-machine.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.StateMachine = void 0;\nconst allowedTransitions = {\n    'stopped': ['stopped', 'idle', 'destroyed'],\n    'idle': ['idle', 'running', 'stopped', 'destroyed'],\n    'running': ['running', 'idle', 'stopped', 'destroyed'],\n    'destroyed': ['destroyed']\n};\nclass StateMachine {\n    state;\n    constructor(initial = 'stopped') {\n        this.state = initial;\n    }\n    changeState(state) {\n        if (allowedTransitions[this.state].includes(state)) {\n            this.state = state;\n        }\n        else {\n            throw new Error(`invalid transition from ${this.state} to ${state}`);\n        }\n    }\n}\nexports.StateMachine = StateMachine;\n//# sourceMappingURL=state-machine.js.map\n\n//# sourceURL=webpack://onda-app-dev/./node_modules/node-cron/dist/cjs/tasks/state-machine.js?\n}");

/***/ }),

/***/ "./node_modules/node-cron/dist/cjs/time/localized-time.js":
/*!****************************************************************!*\
  !*** ./node_modules/node-cron/dist/cjs/time/localized-time.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.LocalizedTime = void 0;\nclass LocalizedTime {\n    timestamp;\n    parts;\n    timezone;\n    constructor(date, timezone) {\n        this.timestamp = date.getTime();\n        this.timezone = timezone;\n        this.parts = buildDateParts(date, timezone);\n    }\n    toDate() {\n        return new Date(this.timestamp);\n    }\n    toISO() {\n        const gmt = this.parts.gmt.replace(/^GMT/, '');\n        const offset = gmt ? gmt : 'Z';\n        const pad = (n) => String(n).padStart(2, '0');\n        return `${this.parts.year}-${pad(this.parts.month)}-${pad(this.parts.day)}`\n            + `T${pad(this.parts.hour)}:${pad(this.parts.minute)}:${pad(this.parts.second)}`\n            + `.${String(this.parts.milisecond).padStart(3, '0')}`\n            + offset;\n    }\n    getParts() {\n        return this.parts;\n    }\n    set(field, value) {\n        this.parts[field] = value;\n        const newDate = new Date(this.toISO());\n        this.timestamp = newDate.getTime();\n        this.parts = buildDateParts(newDate, this.timezone);\n    }\n}\nexports.LocalizedTime = LocalizedTime;\nfunction buildDateParts(date, timezone) {\n    const dftOptions = {\n        year: 'numeric',\n        month: '2-digit',\n        day: '2-digit',\n        hour: '2-digit',\n        minute: '2-digit',\n        second: '2-digit',\n        weekday: 'short',\n        hour12: false\n    };\n    if (timezone) {\n        dftOptions.timeZone = timezone;\n    }\n    const dateFormat = new Intl.DateTimeFormat('en-US', dftOptions);\n    const parts = dateFormat.formatToParts(date).filter(part => {\n        return part.type !== 'literal';\n    }).reduce((acc, part) => {\n        acc[part.type] = part.value;\n        return acc;\n    }, {});\n    return {\n        day: parseInt(parts.day),\n        month: parseInt(parts.month),\n        year: parseInt(parts.year),\n        hour: parts.hour === '24' ? 0 : parseInt(parts.hour),\n        minute: parseInt(parts.minute),\n        second: parseInt(parts.second),\n        milisecond: date.getMilliseconds(),\n        weekday: parts.weekday,\n        gmt: getTimezoneGMT(date, timezone)\n    };\n}\nfunction getTimezoneGMT(date, timezone) {\n    const utcDate = new Date(date.toLocaleString('en-US', { timeZone: 'UTC' }));\n    const tzDate = new Date(date.toLocaleString('en-US', { timeZone: timezone }));\n    let offsetInMinutes = (utcDate.getTime() - tzDate.getTime()) / 60000;\n    const sign = offsetInMinutes <= 0 ? '+' : '-';\n    offsetInMinutes = Math.abs(offsetInMinutes);\n    if (offsetInMinutes === 0)\n        return 'Z';\n    const hours = Math.floor(offsetInMinutes / 60).toString().padStart(2, '0');\n    const minutes = Math.floor(offsetInMinutes % 60).toString().padStart(2, '0');\n    return `GMT${sign}${hours}:${minutes}`;\n}\n//# sourceMappingURL=localized-time.js.map\n\n//# sourceURL=webpack://onda-app-dev/./node_modules/node-cron/dist/cjs/time/localized-time.js?\n}");

/***/ }),

/***/ "./node_modules/node-cron/dist/cjs/time/matcher-walker.js":
/*!****************************************************************!*\
  !*** ./node_modules/node-cron/dist/cjs/time/matcher-walker.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("{\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.MatcherWalker = void 0;\nconst convertion_1 = __importDefault(__webpack_require__(/*! ../pattern/convertion */ \"./node_modules/node-cron/dist/cjs/pattern/convertion/index.js\"));\nconst localized_time_1 = __webpack_require__(/*! ./localized-time */ \"./node_modules/node-cron/dist/cjs/time/localized-time.js\");\nconst time_matcher_1 = __webpack_require__(/*! ./time-matcher */ \"./node_modules/node-cron/dist/cjs/time/time-matcher.js\");\nconst week_day_names_conversion_1 = __importDefault(__webpack_require__(/*! ../pattern/convertion/week-day-names-conversion */ \"./node_modules/node-cron/dist/cjs/pattern/convertion/week-day-names-conversion.js\"));\nclass MatcherWalker {\n    cronExpression;\n    baseDate;\n    pattern;\n    expressions;\n    timeMatcher;\n    timezone;\n    constructor(cronExpression, baseDate, timezone) {\n        this.cronExpression = cronExpression;\n        this.baseDate = baseDate;\n        this.timeMatcher = new time_matcher_1.TimeMatcher(cronExpression, timezone);\n        this.timezone = timezone;\n        this.expressions = (0, convertion_1.default)(cronExpression);\n    }\n    isMatching() {\n        return this.timeMatcher.match(this.baseDate);\n    }\n    matchNext() {\n        const findNextDateIgnoringWeekday = () => {\n            const baseDate = new Date(this.baseDate.getTime());\n            baseDate.setMilliseconds(0);\n            const localTime = new localized_time_1.LocalizedTime(baseDate, this.timezone);\n            const dateParts = localTime.getParts();\n            const date = new localized_time_1.LocalizedTime(localTime.toDate(), this.timezone);\n            const seconds = this.expressions[0];\n            const nextSecond = availableValue(seconds, dateParts.second);\n            if (nextSecond) {\n                date.set('second', nextSecond);\n                if (this.timeMatcher.match(date.toDate())) {\n                    return date;\n                }\n            }\n            date.set('second', seconds[0]);\n            const minutes = this.expressions[1];\n            const nextMinute = availableValue(minutes, dateParts.minute);\n            if (nextMinute) {\n                date.set('minute', nextMinute);\n                if (this.timeMatcher.match(date.toDate())) {\n                    return date;\n                }\n            }\n            date.set('minute', minutes[0]);\n            const hours = this.expressions[2];\n            const nextHour = availableValue(hours, dateParts.hour);\n            if (nextHour) {\n                date.set('hour', nextHour);\n                if (this.timeMatcher.match(date.toDate())) {\n                    return date;\n                }\n            }\n            date.set('hour', hours[0]);\n            const days = this.expressions[3];\n            const nextDay = availableValue(days, dateParts.day);\n            if (nextDay) {\n                date.set('day', nextDay);\n                if (this.timeMatcher.match(date.toDate())) {\n                    return date;\n                }\n            }\n            date.set('day', days[0]);\n            const months = this.expressions[4];\n            const nextMonth = availableValue(months, dateParts.month);\n            if (nextMonth) {\n                date.set('month', nextMonth);\n                if (this.timeMatcher.match(date.toDate())) {\n                    return date;\n                }\n            }\n            date.set('year', date.getParts().year + 1);\n            date.set('month', months[0]);\n            return date;\n        };\n        const date = findNextDateIgnoringWeekday();\n        const weekdays = this.expressions[5];\n        let currentWeekday = parseInt((0, week_day_names_conversion_1.default)(date.getParts().weekday));\n        while (!(weekdays.indexOf(currentWeekday) > -1)) {\n            date.set('year', date.getParts().year + 1);\n            currentWeekday = parseInt((0, week_day_names_conversion_1.default)(date.getParts().weekday));\n        }\n        return date;\n    }\n}\nexports.MatcherWalker = MatcherWalker;\nfunction availableValue(values, currentValue) {\n    const availableValues = values.sort((a, b) => a - b).filter(s => s > currentValue);\n    if (availableValues.length > 0)\n        return availableValues[0];\n    return false;\n}\n//# sourceMappingURL=matcher-walker.js.map\n\n//# sourceURL=webpack://onda-app-dev/./node_modules/node-cron/dist/cjs/time/matcher-walker.js?\n}");

/***/ }),

/***/ "./node_modules/node-cron/dist/cjs/time/time-matcher.js":
/*!**************************************************************!*\
  !*** ./node_modules/node-cron/dist/cjs/time/time-matcher.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("{\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.TimeMatcher = void 0;\nconst index_1 = __importDefault(__webpack_require__(/*! ../pattern/convertion/index */ \"./node_modules/node-cron/dist/cjs/pattern/convertion/index.js\"));\nconst week_day_names_conversion_1 = __importDefault(__webpack_require__(/*! ../pattern/convertion/week-day-names-conversion */ \"./node_modules/node-cron/dist/cjs/pattern/convertion/week-day-names-conversion.js\"));\nconst localized_time_1 = __webpack_require__(/*! ./localized-time */ \"./node_modules/node-cron/dist/cjs/time/localized-time.js\");\nconst matcher_walker_1 = __webpack_require__(/*! ./matcher-walker */ \"./node_modules/node-cron/dist/cjs/time/matcher-walker.js\");\nfunction matchValue(allowedValues, value) {\n    return allowedValues.indexOf(value) !== -1;\n}\nclass TimeMatcher {\n    timezone;\n    pattern;\n    expressions;\n    constructor(pattern, timezone) {\n        this.timezone = timezone;\n        this.pattern = pattern;\n        this.expressions = (0, index_1.default)(pattern);\n    }\n    match(date) {\n        const localizedTime = new localized_time_1.LocalizedTime(date, this.timezone);\n        const parts = localizedTime.getParts();\n        const runOnSecond = matchValue(this.expressions[0], parts.second);\n        const runOnMinute = matchValue(this.expressions[1], parts.minute);\n        const runOnHour = matchValue(this.expressions[2], parts.hour);\n        const runOnDay = matchValue(this.expressions[3], parts.day);\n        const runOnMonth = matchValue(this.expressions[4], parts.month);\n        const runOnWeekDay = matchValue(this.expressions[5], parseInt((0, week_day_names_conversion_1.default)(parts.weekday)));\n        return runOnSecond && runOnMinute && runOnHour && runOnDay && runOnMonth && runOnWeekDay;\n    }\n    getNextMatch(date) {\n        const walker = new matcher_walker_1.MatcherWalker(this.pattern, date, this.timezone);\n        const next = walker.matchNext();\n        return next.toDate();\n    }\n}\nexports.TimeMatcher = TimeMatcher;\n//# sourceMappingURL=time-matcher.js.map\n\n//# sourceURL=webpack://onda-app-dev/./node_modules/node-cron/dist/cjs/time/time-matcher.js?\n}");

/***/ }),

/***/ "./services/cronServices.js":
/*!**********************************!*\
  !*** ./services/cronServices.js ***!
  \**********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{const cron = __webpack_require__(/*! node-cron */ \"./node_modules/node-cron/dist/cjs/node-cron.js\");\r\nconst fs = __webpack_require__(/*! fs */ \"fs\");\r\nconst path = __webpack_require__(/*! path */ \"path\");\r\nconst { Notification } = __webpack_require__(/*! electron */ \"electron\");\r\n\r\nconst SETTINGS_FILE = path.join(__dirname, '../userData/settings.json');\r\nconst CALENDAR_FILE = path.join(__dirname, '../userData/calendar.json');\r\nconst { updateThemeBasedOnTime } = __webpack_require__(/*! ../utils/utils */ \"./utils/utils.js\");\r\n\r\nfunction initCronJobs() {\r\n  // Існуюча логіка для тем\r\n  updateThemeBasedOnTime();\r\n\r\n  const data = fs.readFileSync(SETTINGS_FILE, 'utf8');\r\n  const settings = JSON.parse(data);\r\n  if (settings.theme?.autoThemeSettings?.enabled) {\r\n    const [startHour, startMinute] = settings.theme.autoThemeSettings.startTime\r\n      .split(':')\r\n      .map(Number);\r\n    const [endHour, endMinute] = settings.theme.autoThemeSettings.endTime\r\n      .split(':')\r\n      .map(Number);\r\n\r\n    cron.schedule(`${startMinute} ${startHour} * * *`, () => {\r\n      updateThemeBasedOnTime();\r\n    });\r\n\r\n    cron.schedule(`${endMinute} ${endHour} * * *`, () => {\r\n      updateThemeBasedOnTime();\r\n    });\r\n  }\r\n\r\n  // Нова логіка для сповіщень про події\r\n  cron.schedule('* * * * *', () => {\r\n    // Кожну хвилину\r\n    try {\r\n      const calendarData = fs.readFileSync(CALENDAR_FILE, 'utf8');\r\n      const events = JSON.parse(calendarData);\r\n\r\n      const now = new Date(); // Поточний час: 05:55 PM EEST, 21 травня 2025\r\n      const currentDayOfWeek = now.getDay(); // 3 (середа)\r\n\r\n      // Перевірка, чи увімкнені сповіщення в налаштуваннях\r\n      if (!settings.calendar?.notifications) {\r\n        return; // Якщо сповіщення вимкнені, виходимо з функції\r\n      }\r\n\r\n      events.forEach((event) => {\r\n        let eventDate;\r\n\r\n        // Якщо подія повторюється\r\n        if (event.isRepeating && event.repeatDays.includes(currentDayOfWeek)) {\r\n          // Формуємо дату для поточного дня\r\n          const [hours, minutes] = event.startTime.split(':').map(Number);\r\n          eventDate = new Date(now);\r\n          eventDate.setHours(hours, minutes, 0, 0);\r\n        } else if (event.date) {\r\n          // Якщо подія одноразова\r\n          const [hours, minutes] = event.startTime.split(':').map(Number);\r\n          eventDate = new Date(`${event.date} ${hours}:${minutes}:00`);\r\n        } else {\r\n          return; // Пропускаємо, якщо немає дати\r\n        }\r\n\r\n        const timeDiff = (eventDate - now) / (1000 * 60); // Різниця в хвилинах\r\n        if (timeDiff > 9 && timeDiff <= 10) {\r\n          // Якщо залишилося 10 хвилин або менше\r\n          const notification = new Notification({\r\n            title: 'Нагадування про подію',\r\n            body: `Подія \"${event.title}\" розпочнеться о ${event.startTime} (${event.date || 'сьогодні'})`,\r\n            icon: path.join(__dirname, '../assets/onda-logo.ico'), \r\n          });\r\n          notification.show();\r\n\r\n          notification.on('click', () => {\r\n            if (global.mainWindow) {\r\n              global.mainWindow.focus();\r\n            }\r\n          });\r\n        }\r\n      });\r\n    } catch (err) {\r\n      console.error('Error checking events for notifications:', err);\r\n    }\r\n  });\r\n}\r\n\r\nmodule.exports = { initCronJobs };\r\n\n\n//# sourceURL=webpack://onda-app-dev/./services/cronServices.js?\n}");

/***/ }),

/***/ "./utils/dataUtils.js":
/*!****************************!*\
  !*** ./utils/dataUtils.js ***!
  \****************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{const fs = __webpack_require__(/*! fs */ \"fs\");\n\nconst ensureDataFileExists = (filePath, getTemplate) => {\n  if (!fs.existsSync(filePath)) {\n    const template = getTemplate ? getTemplate() : [];\n\n    fs.writeFileSync(filePath, JSON.stringify(template, null, 2));\n    console.log(`File ${filePath} created`);\n  } else {\n    console.log(`File ${filePath} exists`);\n  }\n};\n// Function to get users data from JSON FILES\nconst getData = async (filePath, getDefaultData = () => []) => {\n  try {\n    ensureDataFileExists(filePath, getDefaultData);\n    const data = await fs.promises.readFile(filePath, 'utf8');\n    return JSON.parse(data);\n  } catch (error) {\n    console.error(`Помилка при читанні файлу ${filePath}:`, error);\n    return Array.isArray(getDefaultData?.()) ? [] : null;\n  }\n};\n// Function to save users data to JSON FILES\nconst saveData = async (filePath, data, getDefaultData = () => []) => {\n  try {\n    ensureDataFileExists(filePath, getDefaultData);\n    await fs.promises.writeFile(filePath, JSON.stringify(data, null, 2));\n    return true;\n  } catch (error) {\n    console.error(`Помилка при збереженні даних:`, error);\n    return false;\n  }\n};\nmodule.exports = { ensureDataFileExists, getData, saveData };\n\n\n//# sourceURL=webpack://onda-app-dev/./utils/dataUtils.js?\n}");

/***/ }),

/***/ "./utils/utils.js":
/*!************************!*\
  !*** ./utils/utils.js ***!
  \************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("{const fs = __webpack_require__(/*! fs */ \"fs\");\nconst path = __webpack_require__(/*! path */ \"path\");\n\nconst SETTINGS_FILE = path.join(__dirname, '../userData/settings.json');\n\nfunction updateThemeBasedOnTime() {\n  const data = fs.readFileSync(SETTINGS_FILE, 'utf8');\n  const settings = JSON.parse(data);\n\n  if (settings.theme.autoThemeSettings.enabled) {\n    const currentHour = new Date().getHours();\n\n    const startTime = settings.theme.autoThemeSettings.startTime;\n    const endTime = settings.theme.autoThemeSettings.endTime;\n\n    const startHour = parseInt(startTime.split(':')[0], 10);\n    const endHour = parseInt(endTime.split(':')[0], 10);\n\n    const isDarkMode = currentHour <= startHour && currentHour > endHour;\n\n    if (settings.theme.darkMode !== isDarkMode) {\n      settings.theme.darkMode = isDarkMode;\n      fs.writeFileSync(SETTINGS_FILE, JSON.stringify(settings, null, 2));\n      console.log(`Theme changed to ${isDarkMode ? 'dark' : 'light'} mode`);\n    }\n  }\n}\n\nmodule.exports = { updateThemeBasedOnTime };\n\n\n//# sourceURL=webpack://onda-app-dev/./utils/utils.js?\n}");

/***/ }),

/***/ "child_process":
/*!********************************!*\
  !*** external "child_process" ***!
  \********************************/
/***/ ((module) => {

"use strict";
module.exports = require("child_process");

/***/ }),

/***/ "crypto":
/*!*************************!*\
  !*** external "crypto" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("crypto");

/***/ }),

/***/ "electron":
/*!***************************!*\
  !*** external "electron" ***!
  \***************************/
/***/ ((module) => {

"use strict";
module.exports = require("electron");

/***/ }),

/***/ "events":
/*!*************************!*\
  !*** external "events" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("events");

/***/ }),

/***/ "fs":
/*!*********************!*\
  !*** external "fs" ***!
  \*********************/
/***/ ((module) => {

"use strict";
module.exports = require("fs");

/***/ }),

/***/ "node:crypto":
/*!******************************!*\
  !*** external "node:crypto" ***!
  \******************************/
/***/ ((module) => {

"use strict";
module.exports = require("node:crypto");

/***/ }),

/***/ "os":
/*!*********************!*\
  !*** external "os" ***!
  \*********************/
/***/ ((module) => {

"use strict";
module.exports = require("os");

/***/ }),

/***/ "path":
/*!***********************!*\
  !*** external "path" ***!
  \***********************/
/***/ ((module) => {

"use strict";
module.exports = require("path");

/***/ }),

/***/ "stream":
/*!*************************!*\
  !*** external "stream" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("stream");

/***/ }),

/***/ "url":
/*!**********************!*\
  !*** external "url" ***!
  \**********************/
/***/ ((module) => {

"use strict";
module.exports = require("url");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./main.js");
/******/ 	
/******/ })()
;